<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Your Study Timeline - OlympiadPrep</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="styles.css">
  <style>
    :root{--fg:#111;--muted:#6b7280;--card:#fff;--accent:#0ea5e9;--grid:#e5e7eb}
    body{color:var(--fg)}
    .container{max-width:1000px;margin:0 auto;padding:0 16px}
    .card{background:var(--card);border-radius:16px;box-shadow:0 1px 4px rgba(0,0,0,.06);padding:16px}
    header .logo{font-weight:800}
    .hint{color:var(--muted);font-size:.92rem}
    .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{cursor:pointer;border:0;background:var(--accent);color:#fff;padding:10px 14px;border-radius:12px;font-weight:600}
    button.secondary{background:#e5e7eb;color:#111}
    input{border:1px solid var(--grid);border-radius:10px;padding:8px 10px}
    .cal-wrap{display:grid;gap:12px;margin-top:12px}
    .month{border:1px solid var(--grid);border-radius:14px;padding:10px}
    .month h3{margin:4px 6px 8px}
    .cal{display:grid;grid-template-columns:repeat(7,1fr);gap:6px}
    .day{border:1px solid var(--grid);border-radius:10px;padding:6px;min-height:110px;background:#fff}
    .day .date{font-weight:700;font-size:.9rem;margin-bottom:2px}
    .out-of-range{opacity:.35}
    .past{opacity:.55}
    .today{outline:2px solid var(--accent)}
    .task{font-size:.86rem;margin:2px 0;line-height:1.25}
    .legend{display:flex;gap:12px;flex-wrap:wrap;margin-top:8px}
    .legend span{font-size:.86rem;background:#f8fafc;border:1px solid var(--grid);padding:4px 8px;border-radius:999px}
    .pager{display:flex;gap:10px;justify-content:center;align-items:center;margin:10px 0 0}
    .pager button:disabled{opacity:.5;cursor:not-allowed}
    @media print{
      .site-header,.toolbar,.pager{display:none!important}
      .month{break-inside:avoid}
      body{background:#fff}
      .card{box-shadow:none;border:1px solid var(--grid)}
    }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="container">
      <h1 class="logo">OlympiadPrep</h1>
      <nav class="site-nav">
        <a href="index.html">Home</a>
        <a href="planning.html">Planning</a>
        <a href="books.html">Books</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <h2>üóìÔ∏è Your Study Timeline</h2>
    <p class="hint" id="planSummary"></p>

    <div class="card toolbar">
      <div>
        <label><b>Minutes per day</b> <input id="mPerDay" type="number" min="15" step="5" style="width:120px"></label>
      </div>
      <div>
        <label><b>Test date</b> <input id="testDate" type="date"></label>
      </div>
      <button id="rebuildBtn" class="secondary">Rebuild plan</button>
      <button id="downloadIcs">Download calendar (.ics)</button>
      <button class="secondary" onclick="window.print()">Print</button>
      <span class="hint">Low time per day ‚Üí more Art of Problem Solving reading; final days still include full mocks.</span>
    </div>

    <div class="legend">
      <span>üìò Reading (Art of Problem Solving Volume 1 or Volume 2)</span>
      <span>üß© Targeted drills (links to exact problems)</span>
      <span>‚è±Ô∏è Timed set (links to specific problems)</span>
      <span>üìù Full mock and review</span>
    </div>

    <section id="calendar" class="cal-wrap"></section>
    <div class="pager">
      <button id="prevMonth">‚Üê Previous month</button>
      <span id="monthLabel" class="hint"></span>
      <button id="nextMonth">Next month ‚Üí</button>
    </div>
  </main>

  <footer>¬© 2025 OlympiadPrep.</footer>

<script>
(function(){
  const input = JSON.parse(localStorage.getItem('studyPlanInput')||'null');
  const planSummary = document.getElementById('planSummary');
  if(!input){
    planSummary.innerHTML='No diagnostic found. Go back to <a href="planning.html">Planning</a>.';
    return;
  }

  // Minimum minutes per block to schedule
  const THRESH = {read:10, drill:10, timed:8};

  // Toolbar defaults
  const today = new Date(); today.setHours(0,0,0,0);
  const todayStr = today.toISOString().slice(0,10);
  document.getElementById('testDate').min = todayStr;
  document.getElementById('mPerDay').value = input.minutesPerDay;
  document.getElementById('testDate').value = input.testDate || todayStr;

  // Window
  const start = new Date(today);
  const end   = new Date(document.getElementById('testDate').value); end.setHours(0,0,0,0);
  const rawDays = Math.ceil((end - start)/86400000);
  const days = (Number.isFinite(rawDays) && rawDays>0) ? rawDays : 14;

  const goalToTestName = {A:'AMC 10/12 (Test A)', B:'AIME bridge (Test B)', C:'US(A)JMO-leaning (Test C)'};
  planSummary.innerHTML = `Start date: <b>${start.toLocaleDateString()}</b> ‚Üí Test date: <b>${end.toLocaleDateString()}</b> ‚Ä¢ Study window: <b>${days}</b> days ‚Ä¢ Goal: <b>${(input.goal||'').toUpperCase()}</b> ‚Ä¢ Track: <b>${goalToTestName[input.testId]||input.testId}</b> ‚Ä¢ Minutes per day: <b>${input.minutesPerDay}</b>.`;

  // Subscores ‚Üí weights
  const subs = input.subscores||{};
  const cats = Object.keys(subs);
  if(!cats.length) cats.push('Polynomials and Algebra','Number Theory','Geometry','Combinatorics','Sequences and Series','Functions','Probability');
  const weights={}; cats.forEach(k=>{const r=(subs[k]?.right||0), t=(subs[k]?.total||1); weights[k]=1 - r/t + 0.05});

  // ---------- Reading references as structured ranges (so we can size by minutes) ----------
  const V1 = 1, V2 = 2;
  const READS_VOL1 = {
    "Number Theory":[
      {vol:V1, chapter:"Chapter 5.4: Modular Arithmetic", pStart:42, pEnd:45},
      {vol:V1, chapter:"Chapter 5.6‚Äì5.7: Primes and Factors", pStart:47, pEnd:48},
    ],
    "Combinatorics":[
      {vol:V1, chapter:"Chapter 25: Learning to Count", pStart:221, pEnd:229},
    ],
    "Probability":[
      {vol:V1, chapter:"Chapter 25: Counting as a foundation for Probability", pStart:221, pEnd:229},
    ],
    "Sequences and Series":[
      {vol:V1, chapter:"Chapter 24: Sequences and Series", pStart:211, pEnd:217},
    ],
    "Functions":[
      {vol:V1, chapter:"Chapter 21: Functions", pStart:187, pEnd:190},
    ],
    "Polynomials and Algebra":[
      {vol:V1, chapter:"Chapter 6: Quadratic Equations", pStart:52, pEnd:60},
    ],
    "Geometry":[
      {vol:V1, chapter:"Chapter 11.8: Area of a Triangle", pStart:109, pEnd:109},
      {vol:V1, chapter:"Chapter 14: Angle Chasing and Chapter 15: Area", pStart:133, pEnd:138},
      {vol:V1, chapter:"Chapter 18: Three-Dimensional Geometry", pStart:165, pEnd:169},
    ],
  };
  const READS_VOL2 = {
    "Number Theory":[
      {vol:V2, chapter:"Chapter 23: Divisibility and Congruences", pStart:252, pEnd:262},
      {vol:V2, chapter:"Chapter 24: Diophantine Equations", pStart:266, pEnd:274},
    ],
    "Combinatorics":[
      {vol:V2, chapter:"Chapter 15: Combinatorics and the Binomial Theorem", pStart:170, pEnd:176},
      {vol:V2, chapter:"Chapter 25.6: Colorings", pStart:280, pEnd:280},
    ],
    "Probability":[
      {vol:V2, chapter:"Chapter 15.5: Binomial Theorem for distributions", pStart:175, pEnd:175},
    ],
    "Sequences and Series":[
      {vol:V2, chapter:"Chapter 16: Sequences and Recurrences", pStart:180, pEnd:191},
    ],
    "Functions":[
      {vol:V2, chapter:"Chapter 7: Functional Equations", pStart:69, pEnd:73},
    ],
    "Polynomials and Algebra":[
      {vol:V2, chapter:"Chapter 6: Polynomials", pStart:52, pEnd:65},
    ],
    "Geometry":[
      {vol:V2, chapter:"Chapter 22: Geometry Tidbits ‚Äî Inversion and Homothety", pStart:241, pEnd:247},
    ],
  };

  function minutesPerPage(vol, isUSAMOTrack){
    // Reading is denser in Volume 2, especially for USAMO track
    if(vol === V1) return 2.0;                 // ‚âà 2 minutes per page
    return isUSAMOTrack ? 3.2 : 2.7;           // Volume 2: ‚âà 2.7‚Äì3.2 minutes per page
  }

  function pickTopic(){
    const sum=Object.values(weights).reduce((a,b)=>a+b,0); let r=Math.random()*sum;
    for(const [k,w] of Object.entries(weights)){ r-=w; if(r<=0) return k; }
    return cats[0];
  }
  function pickReadingObj(cat, onAIMETrack){
    const bank = onAIMETrack ? READS_VOL2 : READS_VOL1;
    const arr=bank[cat]||[];
    if(!arr.length) return null;
    return arr[Math.floor(Math.random()*arr.length)];
  }
  function formatReading(ref, from, to){
    return `Volume ${ref.vol}, ${ref.chapter} (pages ${from}‚Äì${to})`;
  }

  // ---------- AoPS URL builders (for problems) ----------
  function aimeProblemURL(y,v,n){ return `https://artofproblemsolving.com/wiki/index.php/${y}_AIME_${v}_Problems/Problem_${n}`; }
  function aimeSetURL(y,v){ return `https://artofproblemsolving.com/wiki/index.php/${y}_AIME_${v}_Problems`; }
  function amcProblemURL(level,y,v,n){ const L=(level==='10')?'AMC_10':'AMC_12'; return `https://artofproblemsolving.com/wiki/index.php/${y}_${L}${v}_Problems/Problem_${n}`; }
  function amcSetURL(level,y,v){ const L=(level==='10')?'AMC_10':'AMC_12'; return `https://artofproblemsolving.com/wiki/index.php/${y}_${L}${v}_Problems`; }

  const YEARS_AIME = Array.from({length:20},(_,i)=>2004+i);
  const YEARS_AMC  = Array.from({length:18},(_,i)=>2006+i);
  const VARIANTS   = ['A','B'];
  const VAI        = ['I','II'];
  const rnd = arr => arr[Math.floor(Math.random()*arr.length)];

  // Phase / minutes logic with reading priority
  const minutesPerDay = Number(input.minutesPerDay||60);
  const totalDays = days;
  const testId = input.testId; // 'A','B','C'
  const onAIMETrack = (testId!=='A');
  const isUSAMOTrack = (testId==='C');
  const amcLevel = (input.goal==='amc10')?'10':'12';

  function baseMixForPhase(phaseName){
    if(phaseName==='Foundation') return {read:0.65, drill:0.25, timed:0.10};
    if(phaseName==='Mixed')      return {read:0.50, drill:0.35, timed:0.15};
    return                         {read:0.35, drill:0.35, timed:0.30};
  }
  function adjustedMix(base, m){
    let boostRead = 0, takeFromTimed = 0, takeFromDrill = 0;
    if(m <= 30){ boostRead = 0.20; takeFromTimed = 0.15; takeFromDrill = 0.05; }
    else if(m <= 60){ boostRead = 0.10; takeFromTimed = 0.06; takeFromDrill = 0.04; }
    let read = base.read + boostRead;
    let drill = Math.max(0, base.drill - takeFromDrill);
    let timed = Math.max(0, base.timed - takeFromTimed);
    const s = read+drill+timed || 1; read/=s; drill/=s; timed/=s; return {read,drill,timed};
  }
  function phaseNameForDay(d){
    const fEnd = Math.floor(totalDays*0.55);
    const mEnd = Math.floor(totalDays*0.85);
    if(d < fEnd) return 'Foundation';
    if(d < mEnd) return 'Mixed';
    return 'Final';
  }

  // Estimated minutes per problem by track/phase
  function perProblemMinutes(phaseName){
    if(onAIMETrack){
      if(phaseName==='Foundation') return isUSAMOTrack ? 16 : 14;
      if(phaseName==='Mixed')      return isUSAMOTrack ? 18 : 16;
      return                         isUSAMOTrack ? 20 : 18;
    } else {
      if(phaseName==='Foundation') return 9;
      if(phaseName==='Mixed')      return 10;
      return                         12;
    }
  }

  // Count problems to approximately fill the allocated minutes for that block
  function countFromMinutes(blockMinutes, phaseName, isTimed=false){
    const per = perProblemMinutes(phaseName) * (isTimed ? 1.15 : 1.0);
    const target = Math.max(1, Math.floor((blockMinutes + per*0.25) / per));
    const maxCnt = onAIMETrack ? 8 : 10;
    return Math.min(target, maxCnt);
  }

  // Problem pick tuned by goal
  function chooseAIMEProblems(count, phaseName){
    let low=1, high=15;
    if(phaseName==='Foundation'){ low=1; high=isUSAMOTrack?8:7; }
    else if(phaseName==='Mixed'){ low=isUSAMOTrack?5:4; high=isUSAMOTrack?13:12; }
    else { low=isUSAMOTrack?10:6; high=15; }
    const set=new Set(); while(set.size<count) set.add(Math.floor(Math.random()*(high-low+1))+low);
    return [...set].sort((a,b)=>a-b);
  }
  function chooseAMCProblems(level,count,phaseName){
    const ranges = level==='10'
      ? {Foundation:[8,18], Mixed:[12,22], Final:[15,25]}
      : {Foundation:[10,18], Mixed:[12,22], Final:[15,25]};
    const [low,high]=ranges[phaseName]||[10,22];
    const set=new Set(); while(set.size<count) set.add(Math.floor(Math.random()*(high-low+1))+low);
    return [...set].sort((a,b)=>a-b);
  }

  function aimeVariant(){
    if(isUSAMOTrack) return Math.random()<0.7 ? 'II' : 'I';
    return rnd(VAI);
  }

  function makeDrillLinks(phaseName, blockMinutes){
    const count = countFromMinutes(blockMinutes, phaseName, false);
    if(onAIMETrack){
      const y=rnd(YEARS_AIME), v=aimeVariant();
      const nums=chooseAIMEProblems(count, phaseName);
      return nums.map(n=>`<a href="${aimeProblemURL(y,v,n)}" target="_blank" rel="noopener">${y} AIME ${v} Problem ${n}</a>`);
    } else {
      const y=rnd(YEARS_AMC), v=rnd(VARIANTS);
      const nums=chooseAMCProblems(amcLevel, count, phaseName);
      return nums.map(n=>`<a href="${amcProblemURL(amcLevel,y,v,n)}" target="_blank" rel="noopener">${y} AMC ${amcLevel}${v} Problem ${n}</a>`);
    }
  }

  function makeTimedSet(phaseName, blockMinutes){
    const count = countFromMinutes(blockMinutes, phaseName, true);
    if(onAIMETrack){
      const y=rnd(YEARS_AIME), v=aimeVariant();
      const nums=chooseAIMEProblems(count, phaseName);
      return `‚è±Ô∏è Timed: ${nums.map(n=>`<a href="${aimeProblemURL(y,v,n)}" target="_blank" rel="noopener">${y} AIME ${v} Problem ${n}</a>`).join(', ')}`;
    } else {
      const y=rnd(YEARS_AMC), v=rnd(VARIANTS);
      const nums=chooseAMCProblems(amcLevel, count, phaseName);
      return `‚è±Ô∏è Timed: ${nums.map(n=>`<a href="${amcProblemURL(amcLevel,y,v,n)}" target="_blank" rel="noopener">${y} AMC ${amcLevel}${v} Problem ${n}</a>`).join(', ')}`;
    }
  }

  function makeMock(){
    if(onAIMETrack){ const y=rnd(YEARS_AIME), v=aimeVariant(); return {text:`üìù Full mock: ${y} AIME ${v} (15 problems). Review and update your error log.`, href:aimeSetURL(y,v)}; }
    const y=rnd(YEARS_AMC), v=rnd(VARIANTS); return {text:`üìù Full mock: ${y} AMC ${amcLevel}${v}. Review and update your error log.`, href:amcSetURL(amcLevel,y,v)};
  }

  // ---------- NEW: Reading scheduler that fills minutes with pages ----------
  function scheduleReading(blockMinutes){
    const tasks=[]; let remain = blockMinutes; const maxBlocks = 3; let blocks=0;
    while(remain >= 4 && blocks < maxBlocks){ // need at least ~2 pages of V1
      const cat = pickTopic();
      const ref = pickReadingObj(cat, onAIMETrack);
      if(!ref){ break; }
      const rate = minutesPerPage(ref.vol, isUSAMOTrack);
      const available = ref.pEnd - ref.pStart + 1;
      // pages we can fit from this reference
      const pagesTarget = Math.max(2, Math.min(available, Math.floor((remain + 0.3*rate) / rate)));
      const from = ref.pStart;
      const to   = ref.pStart + pagesTarget - 1;
      tasks.push({html:`üìò <b>${cat}</b>: ${formatReading(ref, from, to)} (${pagesTarget} pages ‚Ä¢ ${Math.round(pagesTarget*rate)} minutes)`});
      remain -= pagesTarget * rate;
      blocks++;
      // If we still have a lot of time, loop to add another reading segment (possibly a different topic)
      if(remain < Math.min(THRESH.read/2, rate)) break; // too little time to add another meaningful chunk
    }
    return tasks;
  }

  // ---------- Build tasks by day (reading-first, then drills, then timed) ----------
  const tasksByDay=[];
  for(let d=0; d<totalDays; d++){
    const pName = phaseNameForDay(d);
    const mix  = adjustedMix(baseMixForPhase(pName), minutesPerDay);

    let mRead=Math.round(minutesPerDay*mix.read);
    let mDrill=Math.round(minutesPerDay*mix.drill);
    let mTimed=Math.max(0, minutesPerDay - mRead - mDrill);

    // Reading-first floor
    if(minutesPerDay >= THRESH.read && mRead < THRESH.read){
      let need = THRESH.read - mRead;
      const takeT = Math.min(need, mTimed); mTimed -= takeT; need -= takeT;
      const takeD = Math.min(need, mDrill); mDrill -= takeD; need -= takeD;
      mRead = Math.min(minutesPerDay, mRead + (THRESH.read - Math.max(0,need)));
      if(mRead + mDrill + mTimed > minutesPerDay){
        const diff = mRead + mDrill + mTimed - minutesPerDay;
        const t2 = Math.min(diff, mTimed); mTimed -= t2;
        const rem = diff - t2; if(rem>0) mDrill = Math.max(0, mDrill - rem);
      }
    }

    if(mRead<THRESH.read && mDrill<THRESH.drill && mTimed<THRESH.timed){
      mRead = minutesPerDay; mDrill = 0; mTimed = 0;
    }

    const todayTasks=[];
    if(mRead >= Math.min(THRESH.read, minutesPerDay/2) || (minutesPerDay < THRESH.read && mRead>0)){
      const rTasks = scheduleReading(mRead);
      rTasks.forEach(t => todayTasks.push(t));
    }
    if(mDrill>=THRESH.drill){
      const cat=pickTopic(), links=makeDrillLinks(pName, mDrill);
      todayTasks.push({html:`üß© <b>${cat}</b>: ${links.join(', ')} (${mDrill} minutes)`});
    }
    if(d>=totalDays-3){
      const mk=makeMock();
      todayTasks.push({html:`<a href="${mk.href}" target="_blank" rel="noopener">${mk.text}</a>`});
    } else if(mTimed>=THRESH.timed){
      todayTasks.push({html: makeTimedSet(pName, mTimed)+` (${mTimed} minutes)`});
    }

    // Fallback: if nothing scheduled (rare), fill with reading sized to full minutes
    if(!todayTasks.length){
      const rTasks = scheduleReading(minutesPerDay);
      if(rTasks.length){ rTasks.forEach(t=>todayTasks.push(t)); }
      else {
        const links=makeDrillLinks(pName, minutesPerDay);
        todayTasks.push({html:`üß© <b>${pickTopic()}</b>: ${links.join(', ')} (${minutesPerDay} minutes)`});
      }
    }
    tasksByDay.push(todayTasks);
  }

  // Map date -> tasks
  const taskMap = new Map();
  for(let i=0;i<totalDays;i++){
    const d = new Date(start.getTime()+i*86400000);
    const key = d.toISOString().slice(0,10);
    taskMap.set(key, tasksByDay[i]);
  }

  // Month pager state
  const months = buildMonthList(start, end); // array of {year, month}
  let monthIdx = 0; // start month

  renderOneMonth(months[monthIdx]);

  document.getElementById('prevMonth').onclick = ()=>{
    if(monthIdx>0){ monthIdx--; renderOneMonth(months[monthIdx]); }
  };
  document.getElementById('nextMonth').onclick = ()=>{
    if(monthIdx<months.length-1){ monthIdx++; renderOneMonth(months[monthIdx]); }
  };

  // ICS
  document.getElementById('downloadIcs').onclick = ()=>{
    const ics = buildICS(start, totalDays, tasksByDay, Number(input.minutesPerDay), input);
    const blob = new Blob([ics], {type:'text/calendar'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'OlympiadPrep-StudyPlan.ics';
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  };

  // Rebuild
  document.getElementById('rebuildBtn').onclick = ()=>{
    const m = Number(document.getElementById('mPerDay').value||0);
    const t = document.getElementById('testDate').value;
    if(m<15 || !t){ alert('Enter minutes per day (15 or more) and a future test date.'); return; }
    input.minutesPerDay = m; input.testDate = t;
    localStorage.setItem('studyPlanInput', JSON.stringify(input));
    location.href = 'timeline.html?v=12';
  };

  // Helpers
  function buildMonthList(startDate, endDate){
    const out=[];
    let cur = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
    const last = new Date(endDate.getFullYear(), endDate.getMonth(), 1);
    while(cur <= last){
      out.push({year:cur.getFullYear(), month:cur.getMonth()});
      cur = new Date(cur.getFullYear(), cur.getMonth()+1, 1);
    }
    return out;
  }

  function renderOneMonth({year, month}){
    const cal = document.getElementById('calendar');
    cal.innerHTML = '';
    const wrap = document.createElement('section'); wrap.className='month';
    const header = new Date(year, month, 1).toLocaleString(undefined,{month:'long',year:'numeric'});
    wrap.innerHTML = `<h3>${header}</h3><div class="cal"></div>`;
    const grid = wrap.querySelector('.cal');

    ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'].forEach(d=>{
      const head = document.createElement('div'); head.className='day'; head.style.background='#f8fafc';
      head.innerHTML = `<div class="date" style="opacity:.7">${d}</div>`; grid.appendChild(head);
    });

    const firstDay = new Date(year, month, 1);
    const daysInMonth = new Date(year, month+1, 0).getDate();
    const lead = firstDay.getDay();
    for(let i=0;i<lead;i++){ const e=document.createElement('div'); e.className='day out-of-range'; grid.appendChild(e); }

    for(let day=1; day<=daysInMonth; day++){
      const dateObj = new Date(year, month, day); dateObj.setHours(0,0,0,0);
      const key = dateObj.toISOString().slice(0,10);
      const tasks = taskMap.get(key) || [];
      const inRange = (dateObj >= start && dateObj <= end);

      const box = document.createElement('div');
      let cls = 'day';
      if(!inRange) cls += ' out-of-range';
      else if(dateObj < today) cls += ' past';
      else if(dateObj.getTime() === today.getTime()) cls += ' today';
      box.className = cls;

      let html = `<div class="date">${day}</div>`;
      if(inRange){
        tasks.forEach(t=>{
          html += `<div class="task">${t.html || (t.href? `<a href="${t.href}" target="_blank" rel="noopener">${t.text||'Practice'}</a>` : (t.text||''))}</div>`;
        });
      }
      box.innerHTML = html; grid.appendChild(box);
    }

    cal.appendChild(wrap);

    document.getElementById('monthLabel').innerText = `Month ${monthIdx+1} of ${months.length} ‚Ä¢ ${header}`;
    document.getElementById('prevMonth').disabled = (monthIdx===0);
    document.getElementById('nextMonth').disabled = (monthIdx===months.length-1);
  }

  function buildICS(startDate, spanDays, tasks, minutes, meta){
    function fmtUTC(x){
      const y=x.getUTCFullYear(), m=String(x.getUTCMonth()+1).padStart(2,'0'), d=String(x.getUTCDate()).padStart(2,'0'),
            H=String(x.getUTCHours()).padStart(2,'0'), M=String(x.getUTCMinutes()).padStart(2,'0'), S='00';
      return `${y}${m}${d}T${H}${M}${S}Z`;
    }
    const lines = ['BEGIN:VCALENDAR','VERSION:2.0','PRODID:-//OlympiadPrep//StudyPlan//EN'];
    for(let i=0;i<spanDays;i++){
      const day = new Date(startDate.getTime()+i*86400000);
      const items = tasks[i]||[]; if(!items.length) continue;
      const startUTC = new Date(Date.UTC(day.getFullYear(),day.getMonth(),day.getDate(), 21,0,0));
      const endUTC = new Date(startUTC.getTime()+minutes*60000);
      const desc = items.map(t=> (t.html||'').replace(/<[^>]+>/g,'') ).join('\\n');
      lines.push(
        'BEGIN:VEVENT',
        `UID:olympiadprep-${i}@studyplan`,
        `DTSTAMP:${fmtUTC(new Date())}`,
        `DTSTART:${fmtUTC(startUTC)}`,
        `DTEND:${fmtUTC(endUTC)}`,
        `SUMMARY:Study ‚Ä¢ ${meta.goal.toUpperCase()}`,
        `DESCRIPTION:${desc}`,
        'END:VEVENT'
      );
    }
    lines.push('END:VCALENDAR');
    return lines.join('\r\n');
  }
})();
</script>
</body>
</html>
