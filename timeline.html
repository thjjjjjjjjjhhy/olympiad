<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R641V1KFSP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-R641V1KFSP');
</script>
  <meta charset="utf-8" />
  <title>Your Study Timeline - OlympiadPrep</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Lora:wght@600&family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css" />
  <style>
    :root {
      --bg: #f9fafb;
      --fg: #1f2937;
      --muted: #4b5563;
      --grid: #d1d5db;
      --card: #ffffff;
      --accent: #2563eb;
      --accent-hover: #1d4ed8;
      --shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1);
      --ring: rgba(37, 99, 235, 0.2);
    }
    html,body{
      background-color: var(--bg);
      color: var(--fg);
      font-family: "Open Sans", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .container{max-width:1200px;margin:0 auto;padding:0 24px}

    /* Header */
    .site-header{
      position:sticky; top:0; z-index:10;
      background: var(--card) !important;
      color: var(--fg); padding:16px 0;
      border-bottom: 1px solid var(--grid);
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      margin-bottom: 32px;
    }
    .site-header .container{display:flex; align-items:center; justify-content:space-between; gap:16px; flex-wrap:wrap;}
    .logo{
      font-family: 'Lora', serif;
      font-weight:600;
      color: #111827;
      margin:0;
      font-size: 1.75rem;
    }
    .site-nav{display:flex; gap:16px; flex-wrap:wrap;}
    .site-nav a{ color: var(--fg); text-decoration:none; font-weight:600; padding-bottom: 4px; border-bottom: 2px solid transparent;}
    .site-nav a:hover{ color: var(--accent); border-bottom-color: var(--accent); }
    .site-nav a.active{ color: var(--accent); border-bottom-color: var(--accent); }
    #auth-slot{display:flex;align-items:center;gap:10px;min-height:32px}

    h1, h2, h3 {
      font-family: 'Lora', serif;
      color: #111827;
      font-weight: 600;
    }
    h2 { font-size: 2rem; margin-bottom: 8px; }

    .card{background:var(--card);border-radius:8px;box-shadow:var(--shadow);padding:16px;border:1px solid var(--grid)}
    .error{border-left:4px solid #ef4444;background:#fef2f2;color:#991b1b;padding:12px;border-radius:6px;margin:16px 0;display:none}
    .hint{color:var(--muted);font-size:.875rem}

    /* Toolbar */
    .toolbar{
        display:grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap:16px;
        align-items:end;
        padding: 24px;
        margin-bottom: 24px;
    }
    .toolbar .group { min-width: 120px; }
    .toolbar .group.wide{ grid-column: span 2; }
    @media(max-width: 600px) {
        .toolbar .group.wide { grid-column: span 1; }
    }
    .toolbar label{display:flex;flex-direction:column;gap:6px;font-size:.875rem; font-weight: 600;}
    .toolbar input, .toolbar select{
        width: 100%;
        border: 1px solid var(--grid); 
        border-radius: 6px; 
        padding:8px 12px; 
        font-size: 0.9rem;
        background:#f9fafb;
    }
     .toolbar input:focus, .toolbar select:focus{
      outline:none; border-color:var(--accent); box-shadow: 0 0 0 3px var(--ring);
    }
    .toolbar button{
        cursor:pointer;
        border:0;
        width: 100%;
        background:var(--accent); color:#fff; padding:10px 14px; border-radius:6px; font-weight:700;
        transition: background-color 0.2s;
    }
    .toolbar button:hover { background-color: var(--accent-hover); }
    .toolbar button.secondary{background:#e5e7eb;color:var(--fg); border: 1px solid var(--grid); }
    .toolbar button.secondary:hover { background-color: #d1d5db; }

    /* Legend */
    .legend{display:flex;gap:12px;flex-wrap:wrap;margin: 24px 0; padding: 16px; background-color: #f3f4f6; border-radius: 8px;}
    .legend .lg{font-size:.875rem;color:var(--muted);display:flex;align-items:center;gap:8px; font-weight: 600;}
    .legend .dot{width:10px;height:10px;border-radius:50%;}

    /* Calendar */
    .cal-wrap{display:grid;gap:24px;margin-top:16px}
    .month{border:1px solid var(--grid);border-radius:8px;padding:16px;background:var(--card)}
    .month h3{margin:0 0 16px 0; font-size: 1.5rem;}
    .cal{display:grid;grid-template-columns:repeat(7,1fr);gap:8px}
    .day-header { text-align: center; font-weight: 700; color: var(--muted); font-size: 0.875rem; padding-bottom: 8px; }
    .day{border:1px solid var(--grid);border-radius:6px;padding:8px;min-height:120px;background:var(--card);position:relative; transition: box-shadow .2s, border-color .2s; }
    .day:not(.out-of-range):hover { border-color: #9ca3af; box-shadow: 0 1px 3px rgba(0,0,0,0.08); }
    .day .date{font-weight:700;font-size:.875rem;margin-bottom:6px; color: var(--fg);}
    .out-of-range{background-color: #f9fafb; opacity: .7;}
    .past .date { color: var(--muted); }
    .today{border:2px solid var(--accent);}
    .today .date { color: var(--accent); }

    .task-group h4{font-size:.8rem; margin:8px 0 4px; font-weight:700; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px;}
    .task{font-size:.875rem;margin:4px 0;line-height:1.4;}
    .task .mins{font-size:.8rem;color:var(--muted)}
    .topic-chip{display:inline-block;padding:3px 8px;border-radius:4px;border:1px solid transparent;font-size:.75rem;margin-bottom: 4px; font-weight: 600; background:#eef2ff; color:#3730a3;}
    
    .more{font-size:.875rem;color:var(--accent);cursor:pointer;user-select:none; font-weight: 700;}
    .more-wrap{position:absolute;right:8px;bottom:8px;}
    .fade-bottom{display: none;} /* Simplification, removing fade */

    .pager{display:flex;gap:12px;justify-content:center;align-items:center;margin:24px 0 16px}
    .pager button{cursor:pointer;border:1px solid var(--grid);background:var(--card);color:var(--fg);padding:8px 16px;border-radius:6px;font-weight:700}
    .pager button:hover { background-color: #f3f4f6; }
    .pager button:disabled{opacity:.5;cursor:not-allowed;}
    #monthLabel { font-weight: 600; }
    
    .badge{display:inline-block;border:1px solid var(--grid);border-radius:6px;padding:4px 8px;font-size:.875rem;color:var(--muted);background:var(--card);margin-left:8px}

    /* Modal */
    .modal-backdrop{position:fixed;inset:0;background:rgba(17, 24, 39, 0.6);backdrop-filter: blur(4px);display:none;align-items:center;justify-content:center;padding:16px;z-index:50}
    .modal{max-width:600px;width:100%;background:var(--card);border-radius:8px;box-shadow:0 20px 25px -5px rgba(0,0,0,0.1), 0 8px 10px -6px rgba(0,0,0,0.1);border:1px solid var(--grid)}
    .modal header{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid var(--grid)}
    .modal header h4{margin:0; font-size: 1.25rem;}
    .modal .content{padding:16px;max-height:70vh;overflow:y:auto;}
    .modal .content .task { margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #f3f4f6; }
    .modal .content .task:last-child { border-bottom: none; }
    .modal .content a { color: var(--accent); }
    .pill{display:inline-flex;gap:6px;align-items:center;background:#eef2ff;border:1px solid #dbeafe;padding:4px 10px;border-radius:999px;font-size:.875rem;color:#4338ca;margin-right:8px; font-weight: 600;}
    #closeModal { font-weight: 600; padding: 6px 12px; border-radius: 6px; }

    @media print{
      body { background-color: #fff; }
      .site-header,.toolbar,.pager,.more-wrap,.fade-bottom,.modal-backdrop{display:none!important}
      .month{break-inside:avoid; box-shadow: none; border: 1px solid #ccc;}
      .day{min-height:auto}
      .task{font-size:.9rem}
    }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="container">
        <h1 class="logo">OlympiadPrep</h1>
        <nav class="site-nav">
          <a href="index.html">Home</a>
          <a href="timeline.html" class="active">Timeline</a>
          <a href="tutor.html">Need a Tutor</a>
          <a href="books.html">Books</a>
        </nav>
      <div id="auth-slot"></div>
    </div>
  </header>

  <main class="container">
    <h2 style="display: flex; align-items: center; gap: 12px;">
        <span style="font-size: 1.5em;">üìÖ</span>
        Your Study Timeline
    </h2>
    <div id="errBox" class="error"></div>
    <p class="hint" id="planSummary"></p>

    <div class="card toolbar" id="toolbar">
      <div class="group">
        <label><b>Minutes per day</b><input id="mPerDay" type="number" min="15" step="5" value="60" /></label>
      </div>
      <div class="group">
        <label><b>Test date</b><input id="testDate" type="date" /></label>
      </div>
      <div class="group wide">
        <label><b>Days off</b>
          <select id="daysOff" multiple size="3" title="Hold Ctrl/Cmd to select multiple" style="width:100%">
            <option value="0">Sunday</option><option value="1">Monday</option><option value="2">Tuesday</option>
            <option value="3">Wednesday</option><option value="4">Thursday</option><option value="5">Friday</option><option value="6">Saturday</option>
          </select>
        </label>
      </div>
      <div class="group">
        <label><b>Study time (for .ics)</b>
          <div style="display:flex;gap:6px">
            <select id="studyHour" aria-label="Hour"></select>
            <select id="studyMin" aria-label="Minute"><option>00</option><option>15</option><option>30</option><option>45</option></select>
            <select id="studyAmpm" aria-label="AM/PM"><option>AM</option><option selected>PM</option></select>
          </div>
        </label>
      </div>
      <div class="group">
        <button id="rebuildBtn" class="secondary">Rebuild Plan</button>
      </div>
      <div class="group">
        <button id="downloadIcs">Download .ics</button>
      </div>
      <div class="group">
        <button id="saveCloudBtn" class="secondary">Save to Cloud</button>
        <span id="saveStatus" class="chip" style="display:none">Saved</span>
      </div>
      <div class="group">
        <button class="secondary" onclick="window.print()">Print</button>
      </div>
    </div>

    <div class="legend">
      <span class="lg"><span class="dot" style="background-color: #3b82f6;"></span> Reading</span>
      <span class="lg"><span class="dot" style="background-color: #16a34a;"></span> Exercises</span>
      <span class="lg"><span class="dot" style="background-color: #f97316;"></span> Timed Set</span>
      <span class="lg"><span class="dot" style="background-color: #8b5cf6;"></span> Problem of Day</span>
      <span class="lg"><span class="dot" style="background-color: #64748b;"></span> Mock Exam</span>
      <span class="lg"><span class="dot" style="background-color: #db2777;"></span> Proof Track</span>
      <span class="lg"><span class="dot" style="background-color: #a1a1aa;"></span> Off Day</span>
    </div>

    <div class="pager">
      <button id="prevMonth">‚Üê Prev</button>
      <span id="monthLabel" class="hint"></span>
      <button id="nextMonth">Next ‚Üí</button>
    </div>
    <section id="calendar" class="cal-wrap"></section>
    <div class="pager" style="margin-top: 16px;">
      <button id="prevMonth2">‚Üê Prev</button>
      <button id="nextMonth2">Next ‚Üí</button>
    </div>
  </main>

  <footer class="container" style="text-align:center;margin-top:24px; padding-top:24px; border-top: 1px solid var(--grid);">
    ¬© 2025 OlympiadPrep. A resource for aspiring mathletes.
  </footer>

  <div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="dayTitle">
    <div class="modal" role="document">
      <header>
        <h4 id="dayTitle">Day details</h4>
        <button id="closeModal" class="secondary">Close</button>
      </header>
      <div class="content" id="dayContent"></div>
    </div>
  </div>

  <script>
    /* Safety */
    (function safetyHooks(){
      const errBox = document.getElementById('errBox');
      function show(msg){
        if(!errBox) return;
        errBox.textContent = msg;
        errBox.style.display = 'block';
      }
      window.addEventListener('error', (e)=>{ show('Runtime error: ' + (e.message||'Unknown')); console.error('[error]', e); });
      window.addEventListener('unhandledrejection', (e)=>{ show('Plan build error: ' + ((e.reason&&e.reason.message)||e.reason||'Unknown')); console.error('[unhandledrejection]', e); });
    })();

    /* Utils */
    function $(id){ return document.getElementById(id); }
    function hash32(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0; }
    function sanitizeHTML(input) {
      if(!input) return '';
      input = input.replace(/<\s*(script|style)[^>]*>[\s\S]*?<\s*\/\s*\1\s*>/gi, '');
      input = input.replace(/\s(on\w+)\s*=\s*(['"])[\s\S]*?\2/gi, '');
      input = input.replace(/href\s*=\s*(['"])\s*javascript:[\s\S]*?\1/gi, 'href="#"');
      const allowed = ['a','b','strong','i','em','code','span','div','h4'];
      return input.replace(/<\/?([a-zA-Z0-9]+)(\s[^>]*)?>/g, (m, tag, attrs) => {
        tag = tag.toLowerCase();
        if(!allowed.includes(tag)) return '';
        if(tag === 'a'){
          let href = (attrs||'').match(/href\s*=\s*(['"])(.*?)\1/i);
          let safe = '#';
          if(href && !/^javascript:/i.test(href[2])) safe = href[2];
          return `<a href="${safe}" target="_blank" rel="noopener">`;
        }
        return m;
      });
    }
    function escapeICSText(s){
      if(!s) return '';
      return s.replace(/\r\n|\r|\n/g, '\\n')
             .replace(/\\/g,'\\\\')
             .replace(/,/g,'\\,')
             .replace(/;/g,'\\;');
    }

    /* Hour select */
    (function fillHours(){
      const sel = $('studyHour'); if(!sel) return;
      for(let h=1; h<=12; h++){
        const opt = document.createElement('option'); opt.textContent = String(h).padStart(2,'0'); opt.value = String(h).padStart(2,'0'); sel.appendChild(opt);
      }
      sel.value = '07'; $('studyMin').value = '00'; $('studyAmpm').value = 'PM';
    })();

    /* Load input */
    function loadInput(){
      try{ return JSON.parse(localStorage.getItem('studyPlanInput')||'null'); }
      catch(e){ console.error('Invalid studyPlanInput JSON:', e); return null; }
    }

    (function main(){
      const errBox = $('errBox');
      const input = loadInput();
      const planSummary = $('planSummary');
      if(!input){
        planSummary.innerHTML='No diagnostic found. Go back to <a href="planning.html">Planning</a>.';
        errBox.style.display='block'; errBox.textContent='No plan input found in local storage.';
        return;
      }

      const today = new Date(); today.setHours(0,0,0,0);
      const todayStr = today.toISOString().slice(0,10);
      $('testDate').min = todayStr;

      const minutesPerDay = Number(input.minutesPerDay||60);
      $('mPerDay').value = minutesPerDay;

      const defaultTest = input.testDate || todayStr;
      $('testDate').value = defaultTest;

      const daysOffSel = $('daysOff');
      const storedOff = Array.isArray(input.offDays) ? input.offDays : [];
      for(const opt of daysOffSel.options){ if(storedOff.includes(Number(opt.value))) opt.selected = true; }

      const start = new Date(today);
      const end   = new Date($('testDate').value || todayStr); end.setHours(0,0,0,0);
      if (end < start) {
        planSummary.innerHTML = `Test date must be today or in the future. You selected ${end.toLocaleDateString()}.`;
        errBox.style.display = 'block';
        errBox.textContent = 'Test date cannot be in the past.';
        return;
      }

      const diffDays = Math.floor((end - start)/86400000) + 1; // inclusive window
      const days = (Number.isFinite(diffDays) && diffDays>=1) ? diffDays : 14;

      /* Goal flags */
      const goalStr = String(input.goal||'').toLowerCase();
      const onAIME  = /aime/.test(goalStr) || String(input.testId||'').toUpperCase()==='B';
      const onUSAMO = /usamo|usajmo/.test(goalStr) || String(input.testId||'').toUpperCase()==='C';
      const onAMC8  = /amc8/.test(goalStr) || String(input.testId||'').toUpperCase()==='A8';
      const onAMC10 = /amc10/.test(goalStr);
      const onAMC12 = /amc12/.test(goalStr);
      const onAMC   = (!onAIME && !onUSAMO) || onAMC8 || onAMC10 || onAMC12;

      planSummary.innerHTML =
        `Start: <b>${start.toLocaleDateString()}</b> ‚Üí ` +
        `Test: <b>${end.toLocaleDateString()}</b> ‚Ä¢ ` +
        `Window: <b>${days}</b> days ‚Ä¢ ` +
        `Goal: <b>${(input.goal||'').toUpperCase()}</b> ‚Ä¢ ` +
        `Minutes/day: <b>${minutesPerDay}</b> ` +
        `<span class="badge" id="booksBadge">Books: ${(input.selectedBooks||[]).length||0}</span>`;

      /* RNG */
      const seedStr = (input.generatedAt || input.testDate || todayStr) + '|' + (input.goal||'');
      let _seed = hash32(seedStr);
      function rand(){ _seed ^= _seed << 13; _seed ^= _seed >>> 17; _seed ^= _seed << 5; return ((_seed>>>0) / 4294967296); }
      function pick(arr){ return arr[Math.floor(rand()*arr.length)] }
      function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(rand()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

      /* Topics & weights */
      const subs = input.subscores||{};
      const defaultCats = ['Polynomials and Algebra','Number Theory','Geometry','Combinatorics','Probability','Functions','Sequences and Series','Proof Techniques','Mixed Review'];
      const subsCats = Object.keys(subs);
      const cats = subsCats.length ? subsCats.slice() : defaultCats.slice();

      const TOPIC_ALIASES = {
        'Logic & Proof':'Proof Techniques','Logic and Proof':'Proof Techniques',
        'Transformations':'Geometry','3D Geometry':'Geometry',
        'Polynomials':'Polynomials and Algebra','Algebra':'Polynomials and Algebra',
        'Counting':'Combinatorics','Mixed':'Mixed Review'
      };
      function canonicalTopic(t){ return TOPIC_ALIASES[t] || t; }

      const weights = {};
      (cats.length?cats:defaultCats).forEach(k=>{
        const acc=(subs[k]?.right||0) / Math.max(1,(subs[k]?.total||1));
        weights[k]=(1-acc)+0.05;
      });

      const EMPHASIS = (()=>{
        if(onUSAMO) return {'Geometry':1.3,'Number Theory':1.25,'Polynomials and Algebra':1.2,'Combinatorics':1.12,'Probability':1.0,'Functions':0.95,'Sequences and Series':0.95,'Proof Techniques':1.35,'Mixed Review':1.0};
        if(onAIME)  return {'Number Theory':1.25,'Polynomials and Algebra':1.2,'Combinatorics':1.15,'Geometry':1.05,'Probability':1.0,'Functions':0.95,'Sequences and Series':0.95,'Proof Techniques':0.7,'Mixed Review':0.95};
        return         {'Polynomials and Algebra':1.15,'Number Theory':1.1,'Combinatorics':1.05,'Geometry':1.0,'Probability':1.0,'Functions':0.95,'Sequences and Series':0.95,'Proof Techniques':0.5,'Mixed Review':0.95};
      })();
      Object.keys(weights).forEach(k=>{ weights[k] = (weights[k]||1) * (EMPHASIS[k]||1); });

      /* Topic blocklist: NO Proof Techniques for AMC 8 */
      const TOPIC_BLOCKLIST = onAMC8 ? new Set(['Proof Techniques']) : new Set();

      /* Edition packs */
      const BOOK_PACK_PATH = {
        'aops-v1': 'data/editions/aops-vol1.json',
        'aops-v2': 'data/editions/aops-v2.json',
        'intro-alg': 'data/editions/intro-algebra.json',
        'intro-cp': 'data/editions/intro-counting-prob.json',
        'intro-geo': 'data/editions/intro-geometry.json',
        'intro-nt': 'data/editions/intro-number-theory.json',
        'prealgebra': 'data/editions/prealgebra.json',
        'int-alg': 'data/editions/intermediate-algebra.json',
        'int-cp': 'data/editions/intermediate-counting-prob.json',
        'precalc': 'data/editions/precalculus.json',
        'egmo': 'data/editions/egmo.json',
        'zeitz': 'data/editions/zeitz.json',
        'velleman': 'data/editions/velleman.json',
        'engel': 'data/editions/engel.json',
        '104nt': 'data/editions/104nt.json',
        'path-comb': 'data/editions/path-comb.json',
        'cmms': 'data/editions/cmms.json'
      };
      const PROOF_BOOKS = ['velleman','zeitz','engel','egmo'];

      const selectedBooks = new Set(input.selectedBooks || []);
      const selectedPackIds = Object.keys(BOOK_PACK_PATH).filter(id=>selectedBooks.has(id));

      async function tryFetchPack(id){
        const path = BOOK_PACK_PATH[id];
        if(!path) return null;
        try{
          const r = await fetch(path, {cache:'no-store'});
          if(!r.ok) throw new Error('HTTP '+r.status);
          const j = await r.json();
          return {...j, __bookId:id};
        }catch(e){
          console.warn('Failed to load pack', id, e);
          return null;
        }
      }

      function indexSectionsByTopic(packs){
        const byTopic = {};
        for(const pk of packs){
          const sections = Array.isArray(pk?.sections)? pk.sections : [];
          for(const s of sections){
            const topicRaw = s.topic || 'Polynomials and Algebra';
            const topic = canonicalTopic(topicRaw);
            if (TOPIC_BLOCKLIST.has(topic)) continue; // AMC 8: skip proofs
            if(!byTopic[topic]) byTopic[topic]=[];
            const chapter = s.chapter || s.id || '?';
            byTopic[topic].push({
              bookId: pk.__bookId,
              bookTitle: pk.book || pk.__bookId,
              chapter,
              chapterTitle: s.title || `Chapter ${s.chapter||'?'}`,
              pages: s.pages || '',
              editionMeta: s,
              topic,
              hasExercises: Array.isArray(s.problemRange) && s.problemRange.length>=2,
              sectionKey: `${pk.__bookId}#${chapter}`
            });
          }
        }
        Object.values(byTopic).forEach(arr=>shuffle(arr));
        return byTopic;
      }

      function parsePages(p){
        const t=String(p||'').trim(); if(!t) return null;
        const m=t.match(/(\d+)\s*[‚Äì-]\s*(\d+)/);
        if(m){
          const a=+m[1], b=+m[2];
          if(Number.isFinite(a)&&Number.isFinite(b)&&a>=1&&b>=a) return {from:a,to:b};
          return null;
        }
        const n=+t; if(Number.isFinite(n)&&n>=1) return {from:n,to:n};
        return null;
      }

      /* === BOOK-SPECIFIC MINUTES-PER-PAGE (mpp) ============================= */
      function mppFor(bookId){
        switch(bookId){
          case 'prealgebra': return 3.2;
          case 'aops-v1': return 3.8;
          case 'intro-alg': return 3.8;
          case 'intro-cp': return 3.9;
          case 'intro-geo': return 4.2;
          case 'intro-nt': return 4.0;
          case 'cmms': return 3.5;

          case 'aops-v2': return 4.5;
          case 'int-alg': return 4.6;
          case 'int-cp': return 4.8;
          case 'precalc': return 5.0;

          case 'egmo': return 5.6;
          case 'zeitz': return 5.2;
          case 'velleman': return 5.6;
          case 'engel': return 5.6;
          case '104nt': return 5.0;
          case 'path-comb': return 5.4;
          default: return 4.0;
        }
      }

      /* === TIMING FOR PROBLEMS ============================================== */
      function timeForAMCProblem(level, num){
        if(level==='8'){ return 3.5; }
        if(level==='10' || level==='12'){
          if(num>=1 && num<=10) return 3.5;
          if(num>=11 && num<=14) return 6.0;
          if(num>=15 && num<=25) return 10.0;
        }
        return 4.0;
      }
      function timePerAIMEProblem(){ return 6.5; }
      function timeForBookProblem(sectionMeta, n){
        if(!sectionMeta || !Array.isArray(sectionMeta.problemRange) || sectionMeta.problemRange.length<2) return 3.5;
        const L=Number(sectionMeta.problemRange[0]), R=Number(sectionMeta.problemRange[1]);
        if(!Number.isFinite(L)||!Number.isFinite(R)) return 3.5;
        const hardTail = Math.max(0, Number(sectionMeta.hardTail||0));
        const hardStart = Math.max(L, R - hardTail + 1);
        if(n>=hardStart) return 10.0;
        return 3.5;
      }

      function minutesPerProblem(){ if(onUSAMO) return 9.0; if(onAIME) return 6.5; if(onAMC8) return 3.5; return 4.0; }
      function minProblemsFloor(){ if(onUSAMO) return 2; if(onAIME) return 3; if(onAMC8) return 4; return 5; }

      /* SECTION/PROGRESS UTILITIES */
      const sectionProgress = new Map();      // reading progress per section (pages)
      const consumedSections = new Set();     // reading sections finished
      const catalogCursor = {};               // reading cursor per topic

      const exerciseCursorByTopic = {};       // exercise rotation cursor per topic
      const usedBookProblems = new Set();     // global set of assigned problems (Book#Ch#Num)

      function shortBook(title){
        if(!title) return '';
        const t = title.replace(/Art of Problem Solving|AoPS/gi,'AoPS').replace(/\s+/g,' ').trim();
        return t.replace(/Volume\s+1/,'Vol 1').replace(/Volume\s+2/,'Vol 2');
      }
      function shortChapter(ch){ if(!ch) return ''; return String(ch).replace(/Chapter\s*/i,'ch ').replace(/\s+/g,' ').trim(); }

      function nextUnconsumedSection(topic, catalogByTopic){
        const arr = catalogByTopic[topic] || [];
        if(!arr.length) return null;
        let tries = 0;
        let idx = (catalogCursor[topic]||0) % arr.length;
        while(tries < arr.length){
          const s = arr[idx];
          const key = `${s.bookId}#${s.chapter}`;
          if(!consumedSections.has(key)) {
            catalogCursor[topic] = idx + 1;
            return s;
          }
          idx = (idx+1) % arr.length;
          tries++;
        }
        return null;
      }

      function ensureProgressEntry(section){
        const pg = parsePages(section.pages);
        const key = `${section.bookId}#${section.chapter}`;
        if(!pg) return {key, cur:null, total:null};
        const cur = sectionProgress.get(key) || {from: pg.from, to: pg.from-1};
        return {key, cur, total: pg};
      }

      /* === READING SLICER =================================================== */
      function planReading(topic, minutesBudget, finalPhase, catalogByTopic, commit){
        let remaining = Math.max(0, Math.round(minutesBudget));
        const parts = [];
        let used = 0;

        function consumeFromSection(section){
          const {key, cur, total} = ensureProgressEntry(section);
          const mpp = mppFor(section.bookId);

          if(!total){ // unknown pages -> time-based reading
            const take = Math.max(8, Math.min(remaining, Math.round(minutesBudget*0.8)));
            parts.push({
              bookTitle: section.bookTitle,
              chapterTitle: section.chapterTitle,
              from:null, to:null, mpp,
              minutes: take,
              sectionRef: section
            });
            used += take; remaining -= take;
            return true;
          }

          if(cur.to >= total.to){
            if(commit){ consumedSections.add(key); }
            return false;
          }

          const startPage = Math.max(cur.to+1, total.from);
          let canPages = Math.max(1, Math.floor(remaining / mpp));
          let toPage = Math.min(total.to, startPage + canPages - 1);
          if(toPage < startPage) toPage = startPage;

          const pages = (toPage - startPage + 1);
          const minutes = Math.round(pages * mpp);

          parts.push({
            bookTitle: section.bookTitle,
            chapterTitle: section.chapterTitle,
            from: startPage, to: toPage, mpp, minutes,
            sectionRef: section
          });
          used += minutes; remaining -= minutes;

          if(commit){
            const newTo = toPage;
            sectionProgress.set(key, {from: total.from, to: newTo});
            if(newTo >= total.to) consumedSections.add(key);
          }
          return true;
        }

        let guard = 0;
        while(remaining > 1 && guard < 100){
          guard++;
          let sec = nextUnconsumedSection(topic, catalogByTopic);
          if(!sec) break;
          const ok = consumeFromSection(sec);
          if(!ok) continue;
        }
        const isExhausted = parts.length === 0;
        return { parts, usedMin: Math.max(0, Math.round(parts.reduce((s,p)=>s+(p.minutes||0),0))), isExhausted };
      }

      /* === Exercise helpers ================================================= */
      function problemKey(bookId, chapter, n){
        return `${String(bookId).toUpperCase()}#${chapter}#${n}`;
      }
      function remainingProblemsInfo(section, usedSet){
        const meta = section.editionMeta;
        if(!meta || !Array.isArray(meta.problemRange) || meta.problemRange.length<2){
          return {count:0, minT:Infinity};
        }
        const L = Number(meta.problemRange[0]), R = Number(meta.problemRange[1]);
        if(!Number.isFinite(L)||!Number.isFinite(R)||L>R) return {count:0,minT:Infinity};
        let count = 0, minT = Infinity;
        for(let n=L;n<=R;n++){
          const id = problemKey(section.bookId, section.chapter, n);
          if(!usedSet.has(id)){
            count++;
            const t = timeForBookProblem(meta, n);
            if(t < minT) minT = t;
          }
        }
        return {count, minT: (minT===Infinity? 1e9 : minT)};
      }

      function difficultyTarget(topicKey, dayIndex, totalDays){
        if(onAMC8){
          const early = dayIndex < Math.floor(totalDays*0.55);
          const acc = (subs?.[topicKey]?.right || 0) / Math.max(1, (subs?.[topicKey]?.total || 1));
          if(early) return 'easy';
          if(acc < 0.5) return 'mixed';
          return 'mixed';
        }
        const acc = (subs?.[topicKey]?.right || 0) / Math.max(1, (subs?.[topicKey]?.total || 1));
        const early = dayIndex < Math.floor(totalDays*0.5);
        if (acc < 0.35) return early ? 'easy' : 'mixed';
        if (acc < 0.7)  return early ? 'mixed' : 'hard';
        return early ? 'mixed' : 'hard';
      }

      function chooseBookProblemsForBudget(section, minutesBudget, target, usedSet){
        const meta = section.editionMeta;
        const picked = [];
        if(!meta || !Array.isArray(meta.problemRange) || meta.problemRange.length<2) return {nums:picked, minutes:0, exhausted:true};

        const sectionTag = `${String(section.bookId).toUpperCase()}#${section.chapter}`;

        const L = Number(meta.problemRange[0]), R = Number(meta.problemRange[1]);
        const allAvail = [];
        for(let n=L;n<=R;n++){
          const id = `${sectionTag}#${n}`;
          if(!usedSet.has(id)) allAvail.push(n);
        }
        if(allAvail.length===0) return {nums:picked, minutes:0, exhausted:true};

        const hardTail = Math.max(0, Number(meta.hardTail||0));
        const hardStart = Math.max(L, R - hardTail + 1);
        const easy=[], mid=[], hard=[];
        for(const n of allAvail){
          if (hardTail>0 && n>=hardStart) { hard.push(n); continue; }
          const pos = (n - L) / Math.max(1, (R - L + 1) - hardTail);
          if (pos <= 0.34) easy.push(n);
          else if (pos <= 0.67) mid.push(n);
          else hard.push(n);
        }
        const order = (target==='hard')? [hard,mid,easy] : (target==='easy')? [easy,mid,hard] : [mid,easy,hard];

        let total = 0;
        const takeFrom = (pool)=>{
          shuffle(pool);
          while(pool.length){
            const n = pool.pop();
            const t = timeForBookProblem(meta, n);
            if(total + t <= minutesBudget + 0.01){
              picked.push(n); total += t;
            }
            if(minutesBudget - total < 2.0) break;
          }
        };
        for(const pool of order){
          if(minutesBudget - total < 2.0) break;
          takeFrom(pool);
        }

        for(const n of picked){
          usedSet.add(`${sectionTag}#${n}`);
        }
        return {nums:picked, minutes:Math.round(total), exhausted: picked.length===0 && allAvail.length===0};
      }

      function makeExercisesFromSection(section, minutesBudget, dayIndex, totalDays, usedSet){
        const topic = section.topic || 'Polynomials and Algebra';
        const target = difficultyTarget(topic, dayIndex, totalDays);

        const rem = remainingProblemsInfo(section, usedSet);
        if(rem.count===0 || rem.minT > minutesBudget + 0.01){
          return null;
        }

        const chosen = chooseBookProblemsForBudget(section, minutesBudget, target, usedSet);
        const baseDesc = `Ex: ${section.chapterTitle}`;
        const longBase = `üß† <b>Book exercises</b> (${section.bookTitle}, ${section.chapterTitle})`;

        if(!chosen.nums.length){
          return null; // fall back to timed set
        }
        const numsSorted = chosen.nums.slice().sort((a,b)=>a-b);
        const text = (numsSorted.length<=10) ? numsSorted.join(', ') : `${Math.min(...numsSorted)}‚Äì${Math.max(...numsSorted)} (selected)`;
        return {
          display: `${baseDesc}: ${text}`,
          long: `${longBase}: ${text}`,
          mins: chosen.minutes, type:'bookex', _topic: topic, _exCount: numsSorted.length, _exNums: numsSorted, _section: section, _book: shortBook(section.bookTitle)
        };
      }

      /* Contest links */
      function amcProbURL(year, level, variant, num){
        const L=(level==='10')?'AMC_10':'AMC_12';
        return `https://artofproblemsolving.com/wiki/index.php/${year}_${L}${variant}_Problems/Problem_${num}`;
      }
      function amc8ProbURL(year, num){
        return `https://artofproblemsolving.com/wiki/index.php/${year}_AMC_8_Problems/Problem_${num}`;
      }
      function aimeProbURL(year, variant, num){
        return `https://artofproblemsolving.com/wiki/index.php/${year}_AIME_${variant}_Problems/Problem_${num}`;
      }
      function usamoProbURL(year, num){
        return `https://artofproblemsolving.com/wiki/index.php/${year}_USAMO_Problems/Problem_${num}`;
      }
      function usajmoProbURL(year, num){
        return `https://artofproblemsolving.com/wiki/index.php/${year}_USAJMO_Problems/Problem_${num}`;
      }

      const usedContest = new Set();
      function problemOfDay(){
        const todayYear = new Date().getFullYear();
        const years = []; for(let y=todayYear-20; y<=todayYear-1; y++) years.push(y);
        let tries = 0;
        while(tries<500){
          tries++;
          const y = pick(years);
          if(onAIME){
            const variant = pick(['I','II']);
            const num = 1 + Math.floor(rand()*15);
            const id = `AIME-${y}-${variant}-${num}`;
            if(usedContest.has(id)) continue;
            usedContest.add(id);
            return {display:`${y} AIME ${variant} ‚Ä¢ #${num}`, long:`üß© <a href="${aimeProbURL(y,variant,num)}" target="_blank" rel="noopener">Problem of the day: ${y} AIME ${variant} ‚Ä¢ Problem ${num}</a>`, mins: 10, type: 'potd', _book:'üß© Problem of the Day'};
          } else if(onUSAMO){
            if(/usajmo/.test(goalStr)){
              const num = 1 + Math.floor(rand()*6);
              const id = `USAJMO-${y}-${num}`; if(usedContest.has(id)) continue;
              usedContest.add(id);
              return {display:`${y} USAJMO ‚Ä¢ #${num}`, long:`üß© <a href="${usajmoProbURL(y,num)}" target="_blank" rel="noopener">Problem of the day: ${y} USAJMO ‚Ä¢ Problem ${num}</a>`, mins: 12, type:'potd', _book:'üß© Problem of the Day'};
            } else {
              const num = 1 + Math.floor(rand()*6);
              const id = `USAMO-${y}-${num}`; if(usedContest.has(id)) continue;
              usedContest.add(id);
              return {display:`${y} USAMO ‚Ä¢ #${num}`, long:`üß© <a href="${usamoProbURL(y,num)}" target="_blank" rel="noopener">Problem of the day: ${y} USAMO ‚Ä¢ Problem ${num}</a>`, mins: 15, type:'potd', _book:'üß© Problem of the Day'};
            }
          } else {
            if(onAMC8){
              const num = 1 + Math.floor(rand()*25);
              const id = `AMC8-${y}-${num}`;
              if(usedContest.has(id)) continue;
              usedContest.add(id);
              return {display:`${y} AMC 8 ‚Ä¢ #${num}`, long:`üß© <a href="${amc8ProbURL(y,num)}" target="_blank" rel="noopener">Problem of the day: ${y} AMC 8 ‚Ä¢ Problem ${num}</a>`, mins: 6, type: 'potd', _book:'üß© Problem of the Day'};
            } else {
              const level = (onAMC10)?'10':'12';
              const variant = pick(['A','B']);
              const num = 1 + Math.floor(rand()*20);
              const id = `AMC${level}-${y}-${variant}-${num}`;
              if(usedContest.has(id)) continue;
              usedContest.add(id);
              return {display:`${y} AMC ${level}${variant} ‚Ä¢ #${num}`, long:`üß© <a href="${amcProbURL(y,level,variant,num)}" target="_blank" rel="noopener">Problem of the day: ${y} AMC ${level}${variant} ‚Ä¢ Problem ${num}</a>`, mins: 8, type:'potd', _book:'üß© Problem of the Day'};
            }
          }
        }
        return {display:`Contest problem`, long:`üß© Problem of the day: see recent contests on AoPS`, mins:8, type:'potd', _book:'üß© Problem of the Day'};
      }

      /* AMC/ AIME timed sets */
      function buildAMCContestTimedSet(minutesBudget){
        const todayYear = new Date().getFullYear();
        const years = []; for(let y=todayYear-18; y<=todayYear-1; y++) years.push(y);
        const variant = pick(['A','B']);
        const level = onAMC8 ? '8' : (onAMC10 ? '10' : '12');
        const year = pick(years);

        const easyPool = Array.from({length:10}, (_,i)=>i+1);
        const midPool  = Array.from({length:4},  (_,i)=>i+11);
        const hardPool = Array.from({length:11}, (_,i)=>i+15);

        function nextFrom(pool){ shuffle(pool); return pool.shift(); }

        const target = (function(){
          const acc = (Object.values(subs).reduce((s,v)=>s+(v?.right||0),0)) / Math.max(1,Object.values(subs).reduce((s,v)=>s+(v?.total||0),0));
          if(acc<0.35) return 'easy';
          if(acc<0.7)  return 'mixed';
          return 'hard';
        })();

        let order;
        if(target==='easy') order = [easyPool, midPool, hardPool];
        else if(target==='hard') order = [hardPool, midPool, easyPool];
        else order = [easyPool, midPool, hardPool];

        const chosen=[]; let total=0;
        const pools = order.map(p=>p.slice());
        let guard=0;
        while(total < minutesBudget - 1.0 && guard<200){
          guard++;
          for(const pool of pools){
            const num = nextFrom(pool);
            if(num==null) continue;
            const t = timeForAMCProblem(level, num);
            if(total + t <= minutesBudget + 0.01){
              chosen.push(num); total += t;
            }
            if(total >= minutesBudget - 1.0) break;
          }
          if(pools.every(p=>p.length===0)) break;
        }
        chosen.sort((a,b)=>a-b);

        const mins = Math.round(total);
        let display,long, book;
        if(level==='8'){
          book = `‚è±Ô∏è Timed ‚Äî AMC 8 ${year}`;
          display = `Problems: ${chosen.join(', ')}`;
          const links = chosen.map(n=>`<a href="${amc8ProbURL(year,n)}">#${n}</a>`).join(', ');
          long = `‚è±Ô∏è <b>Timed set</b> ‚Äî AMC 8 ${year}: ${links}`;
        } else {
          book = `‚è±Ô∏è Timed ‚Äî AMC ${level}${variant} ${year}`;
          display = `Problems: ${chosen.join(', ')}`;
          const links = chosen.map(n=>`<a href="${amcProbURL(year,level,variant,n)}">#${n}</a>`).join(', ');
          long = `‚è±Ô∏è <b>Timed set</b> ‚Äî AMC ${level}${variant} ${year}: ${links}`;
        }
        return {display, long, mins, type:'timed', _book: book, _contest:`AMC${level}`, _year:year, _variant:variant, _nums:chosen, _perProblemFn:(n)=>timeForAMCProblem(level,n)};
      }

      function buildAIMETimedSet(minutesBudget){
        const todayYear = new Date().getFullYear();
        const years = []; for(let y=todayYear-18; y<=todayYear-1; y++) years.push(y);
        const year = pick(years);
        const variant = pick(['I','II']);
        const pool = Array.from({length:15}, (_,i)=>i+1);
        shuffle(pool);

        const chosen=[]; let total=0;
        for(const n of pool){
          const t = timePerAIMEProblem();
          if(total + t <= minutesBudget + 0.01){ chosen.push(n); total += t; }
          if(minutesBudget - total < 2.0) break;
        }
        chosen.sort((a,b)=>a-b);

        const mins = Math.round(total);
        const book = `‚è±Ô∏è Timed ‚Äî AIME ${variant} ${year}`;
        const display = `Problems: ${chosen.join(', ')}`;
        const links = chosen.map(n=>`<a href="${aimeProbURL(year,variant,n)}">#${n}</a>`).join(', ');
        const long = `‚è±Ô∏è <b>Timed set</b> ‚Äî AIME ${variant} ${year}: ${links}`;
        return {display, long, mins, type:'timed', _book:book, _contest:`AIME${variant}`, _year:year, _variant:variant, _nums:chosen, _perProblemFn:()=>timePerAIMEProblem()};
      }

      /* Mocks */
      const currentYear = new Date().getFullYear();
      const MOCK_YEARS = []; for(let y=currentYear-1; y>=2000; y--) MOCK_YEARS.push(y);
      let mockYearIdx = 0;
      function nextMockYear(){ const y = MOCK_YEARS[mockYearIdx % MOCK_YEARS.length]; mockYearIdx++; return y; }
      function aimeSetURL(y,v){ return `https://artofproblemsolving.com/wiki/index.php/${y}_AIME_${v}_Problems`; }
      function amcSetURL(level,y,v){ const L=(level==='10')?'AMC_10':'AMC_12'; return `https://artofproblemsolving.com/wiki/index.php/${y}_${L}${v}_Problems`; }
      function amc8SetURL(y){ return `https://artofproblemsolving.com/wiki/index.php/${y}_AMC_8_Problems`; }
      function jmoSetURL(y){ return `https://artofproblemsolving.com/wiki/index.php/${y}_USAJMO_Problems`; }
      function usamoSetURL(y){ return `https://artofproblemsolving.com/wiki/index.php/${y}_USAMO_Problems`; }

      function makeMock(totalMinutes){
        const y = nextMockYear();
        if(onUSAMO){
          if(/usajmo/.test(goalStr)){
            return {display:`USAJMO ${y} full mock`, long:`üìù <a href="${jmoSetURL(y)}" target="_blank" rel="noopener">Full mock: ${y} USAJMO</a> ‚Ä¢ Review & update your error log.`, mins: totalMinutes, type:'mock', _book:'üìù Mock Exam'};
          } else {
            return {display:`USAMO ${y} full mock`, long:`üìù <a href="${usamoSetURL(y)}" target="_blank" rel="noopener">Full mock: ${y} USAMO</a> ‚Ä¢ Review & update your error log.`, mins: totalMinutes, type:'mock', _book:'üìù Mock Exam'};
          }
        }
        if(onAIME){
          const variant = (mockYearIdx % 2 === 0) ? 'I' : 'II';
          return {display:`AIME ${variant} ${y} full mock`, long:`üìù <a href="${aimeSetURL(y,variant)}" target="_blank" rel="noopener">Full mock: ${y} AIME ${variant} (15 problems)</a> ‚Ä¢ Review thoroughly.`, mins: totalMinutes, type:'mock', _book:'üìù Mock Exam'};
        }
        if(onAMC8){
          return {display:`AMC 8 ${y} mock`, long:`üìù <a href="${amc8SetURL(y)}" target="_blank" rel="noopener">Full mock: ${y} AMC 8</a> ‚Ä¢ Review & update your error log.`, mins: totalMinutes, type:'mock', _book:'üìù Mock Exam'};
        }
        const level = (onAMC10)?'10':'12';
        const variant = (mockYearIdx % 2 === 0) ? 'A' : 'B';
        return {display:`AMC ${level}${variant} ${y} mock`, long:`üìù <a href="${amcSetURL(level,y,variant)}" target="_blank" rel="noopener">Full mock: ${y} AMC ${level}${variant}</a> ‚Ä¢ Review & update your error log.`, mins: totalMinutes, type:'mock', _book:'üìù Mock Exam'};
      }

      /* Proof gating */
      const hasProofBooks = (input.selectedBooks||[]).some(id=>PROOF_BOOKS.includes(id));
      const proofUnits = [];
      if(hasProofBooks){
        if(selectedBooks.has('velleman')) proofUnits.push({label:'Velleman ‚Äî Direct & Contrapositive Proofs', mins:25});
        if(selectedBooks.has('velleman')) proofUnits.push({label:'Velleman ‚Äî Mathematical Induction', mins:25});
        if(selectedBooks.has('zeitz'))    proofUnits.push({label:'Zeitz ‚Äî Invariants & Extremal', mins:25});
        if(selectedBooks.has('engel'))    proofUnits.push({label:'Engel ‚Äî Combinatorial Strategies', mins:25});
        if(selectedBooks.has('egmo'))     proofUnits.push({label:'EGMO ‚Äî Power of a Point & Homothety', mins:25});
        if(selectedBooks.has('egmo'))     proofUnits.push({label:'EGMO ‚Äî Inversion Basics', mins:25});
        shuffle(proofUnits);
      }
      let proofCursor=0;
      function scheduleProof(blockMinutes){
        const out=[]; let used=0;
        while(used+20<=blockMinutes && proofUnits.length){
          const it = proofUnits[proofCursor++ % proofUnits.length];
          out.push({display:`${it.label}`, long:`üìó <b>Proof track</b>: ${it.label}. Write at least one full proof.`, mins: it.mins, type:'proof', _book:'üìó Proof Track'});
          used += it.mins;
        }
        if(blockMinutes - used >= 14 && proofUnits.length){
          const it = proofUnits[proofCursor % proofUnits.length];
          out.push({display:`${it.label} (short)`, long:`üìó <b>Proof track</b>: ${it.label} (short set).`, mins: blockMinutes-used, type:'proof', _book:'üìó Proof Track'});
        }
        return out;
      }

      /* Build plan */
      (async function buildPlan(){
        try{
          const packs = (await Promise.all(selectedPackIds.map(id => tryFetchPack(id)))).filter(Boolean);
          const catalogByTopic = indexSectionsByTopic(packs);
          $('booksBadge').textContent = `Books: ${selectedPackIds.length}`;

          // Only allow exercises from books that actually contain problem ranges
          const EXERCISE_BOOKS = new Set(
            packs.filter(pk => Array.isArray(pk.sections) && pk.sections.some(s => Array.isArray(s.problemRange) && s.problemRange.length>=2))
                 .map(pk => pk.__bookId)
          );

          // Helper: are ALL allowed reading sections fully finished?
          function allReadingDoneSoFar(){
            for(const pk of packs){
              const secs = Array.isArray(pk.sections) ? pk.sections : [];
              for(const s of secs){
                const topic = canonicalTopic(s.topic || 'Polynomials and Algebra');
                if (TOPIC_BLOCKLIST.has(topic)) continue; // blocked topics ignored
                const pages = parsePages(s.pages);
                if(!pages) return false; // unknown page ranges count as not finished
                const key = `${pk.__bookId}#${(s.chapter || s.id || '?')}`;
                const prog = sectionProgress.get(key);
                if(!(prog && Number.isFinite(prog.to) && prog.to >= pages.to)) return false;
              }
            }
            return true;
          }

          /* Thresholds */
          const TH = onAMC8 ? { readMin: 12, drillMin: 14, timedMin: 8 } : { readMin: 14, drillMin: 16, timedMin: 10 };
          const totalDays = days;

          const mockStartIdx = onAMC8 ? Math.max(0, totalDays - 21) : Math.max(0, totalDays - 30);
          const mockWeekdays = new Set([2,4,6]); // Tue, Thu, Sat
          const offDaySet = new Set(storedOff.map(Number));

          const seenTopics = new Map();

          function allAvailableTopics(fromCatalog){
            const fromPacks = Object.keys(fromCatalog);
            const base = new Set([...fromPacks, ...defaultCats.map(canonicalTopic)]);
            return Array.from(base).filter(t => !TOPIC_BLOCKLIST.has(canonicalTopic(t)));
          }
          const availableTopics = allAvailableTopics(catalogByTopic);

          function pickNextTopic(){
            const unseen = availableTopics.filter(t => (seenTopics.get(t)||0)===0);
            const domain = unseen.length ? unseen : availableTopics;
            let best = domain[0], bestScore = -1;
            for(const t of domain){
              const w = (weights[canonicalTopic(t)]||1);
              const n = (seenTopics.get(t)||0);
              const coverageBonus = 1 + 0.15*Math.max(0, 5-n);
              const score = w * coverageBonus;
              if(score>bestScore){ bestScore=score; best=t; }
            }
            seenTopics.set(best, (seenTopics.get(best)||0)+1);
            return canonicalTopic(best);
          }

          function baseMixForPhase(ph){
            if(onAMC8){
              if(ph==='Foundation') return {read:0.60, drill:0.34, timed:0.06};
              if(ph==='Mixed')     return {read:0.50, drill:0.38, timed:0.12};
              return                 {read:0.40, drill:0.42, timed:0.18};
            }
            if(ph==='Foundation') return {read:0.56, drill:0.34, timed:0.10};
            if(ph==='Mixed')     return {read:0.46, drill:0.38, timed:0.16};
            return                 {read:0.36, drill:0.42, timed:0.22};
          }
          function phaseNameForDay(d){
            const f=Math.floor(totalDays*0.55), m=Math.floor(totalDays*0.85);
            return d<f?'Foundation':(d<m?'Mixed':'Final');
          }
          function adjustedMix(base, minutes){
            let r=base.read, d=base.drill, t=base.timed;
            if(minutes<=30){ r+=0.08; d+=0.03; t-=0.11; }
            if(onUSAMO){ r+=0.02; d-=0.02; }
            const s=r+d+t; r/=s; d/=s; t/=s; return {read:r,drill:d,timed:t};
          }

          function totalMin(ts){ return Math.round(ts.reduce((s,t)=>s+(t.mins||0),0)); }

          function commitReadingForMinutes(topic, minutes, finalPhase, catalogByTopic){
            return planReading(topic, minutes, finalPhase, catalogByTopic, true);
          }

          function findExerciseSectionForTopic(topic, minutesBudget){
            const arr = catalogByTopic[topic] || [];
            if(!arr.length) return null;
            const startIdx = (exerciseCursorByTopic[topic] || 0) % arr.length;

            for(let k=0; k<arr.length; k++){
              const idx = (startIdx + k) % arr.length;
              const s = arr[idx];
              if(!s.hasExercises) continue;
              if(!EXERCISE_BOOKS.has(s.bookId)) continue;

              const rem = remainingProblemsInfo(s, usedBookProblems);
              if(rem.count === 0) continue;
              if(rem.minT > minutesBudget + 0.01) continue;

              exerciseCursorByTopic[topic] = idx + 1;
              return s;
            }
            return null;
          }

          // Fill reading minutes from other topics when primary topic is exhausted
          function fillReadingAcrossTopics(minutesBudget, isFinalPhase){
            const added = [];
            let remain = Math.max(0, minutesBudget);
            const tried = new Set();
            let guard = 0;

            while(remain > 3 && guard < availableTopics.length + 5){
              guard++;
              let candidate = null, bestScore=-1;
              for(const t of availableTopics){
                if(tried.has(t)) continue;
                const sec = nextUnconsumedSection(t, catalogByTopic);
                if(!sec){ tried.add(t); continue; }
                const score = (weights[canonicalTopic(t)]||1) + Math.random()*0.01;
                if(score>bestScore){ bestScore=score; candidate=t; }
              }
              if(!candidate) break;
              tried.add(candidate);

              const plan = commitReadingForMinutes(candidate, remain, isFinalPhase, catalogByTopic);
              if(plan.usedMin>0 && plan.parts.length){
                plan.parts.forEach(p=>{
                  const pageStr = p.from ? (p.from === p.to ? ` (p.${p.from})` : ` (pp.${p.from}‚Äì${p.to})`) : '';
                  added.push({
                    display: `Read: ${p.chapterTitle}${pageStr}`,
                    long: `üìò <b>${candidate}</b>: ${p.bookTitle}, ${p.chapterTitle}${pageStr}`,
                    mins: p.minutes, type: 'reading',
                    _topic: candidate, _book: shortBook(p.bookTitle),
                    _section: p.sectionRef
                  });
                });
                remain -= plan.usedMin;
              }
            }
            return {items:added, used: minutesBudget - remain};
          }

          // --- Choose exercises based on the day's actual reading blocks ---
          function chooseExerciseTargetFromReadings(readingTasks, minutesBudget){
            for(let i = readingTasks.length - 1; i >= 0; i--){
              const rt = readingTasks[i];
              const s = rt._section;
              if(!s) continue;
              if(!s.hasExercises) continue;
              if(!EXERCISE_BOOKS.has(s.bookId)) continue;
              const rem = remainingProblemsInfo(s, usedBookProblems);
              if(rem.count === 0) continue;
              if(rem.minT > minutesBudget + 0.01) continue;
              return s;
            }
            return null;
          }

          function buildDay(dayIndex, dateObj){
            const weekday = dateObj.getDay();
            const phase = phaseNameForDay(dayIndex);
            const isFinalPhase = (phase==='Final');

            if(offDaySet.has(weekday)){
              return [{display:'Rest / light review', long:'üåø Off day (rest / review errors lightly)', mins:0, type:'off', _book:'üåø Off Day'}];
            }
            const inMockPhase = (dayIndex >= mockStartIdx);
            const isMockDay = inMockPhase && mockWeekdays.has(weekday);
            if(isMockDay){
              return [makeMock(minutesPerDay)];
            }

            if(minutesPerDay <= 22){
              const allDone = allReadingDoneSoFar();
              if(allDone){
                return [{display:`Targeted review & error log`, long:`üåÄ Review previously missed problems and key formulas across topics.`, mins: minutesPerDay, type: 'review', _book:`üåÄ Review: Mixed`}];
              }
              const topic = pickNextTopic();
              const planned = commitReadingForMinutes(topic, minutesPerDay, isFinalPhase, catalogByTopic);
              if (planned.isExhausted || planned.usedMin===0){
                const fill = fillReadingAcrossTopics(minutesPerDay, isFinalPhase);
                if(fill.items.length) return fill.items;
                return [onAIME ? buildAIMETimedSet(minutesPerDay) : buildAMCContestTimedSet(minutesPerDay)];
              }
              return planned.parts.map(p => {
                const pageStr = p.from ? (p.from === p.to ? ` (p.${p.from})` : ` (pp.${p.from}‚Äì${p.to})`) : '';
                return {
                    display: `Read: ${p.chapterTitle}${pageStr}`,
                    long: `üìò <b>${topic}</b>: ${p.bookTitle}, ${p.chapterTitle}${pageStr}`,
                    mins: p.minutes, type: 'reading', _topic: topic, _book: shortBook(p.bookTitle),
                    _section: p.sectionRef
                };
              });
            }

            const mix = adjustedMix(baseMixForPhase(phase), minutesPerDay);
            let mRead = Math.max(TH.readMin, Math.round(minutesPerDay*mix.read));
            let mDrill= Math.max(TH.drillMin, Math.round(minutesPerDay*mix.drill));
            let mTimed= Math.max(TH.timedMin, Math.round(minutesPerDay*mix.timed));
            
            let sum = mRead+mDrill+mTimed;
            if(sum>minutesPerDay){
              const over = sum - minutesPerDay;
              const cutT = Math.min(over, Math.max(0, mTimed-TH.timedMin)); mTimed-=cutT;
              const cutD = Math.min(over-cutT, Math.max(0, mDrill-TH.drillMin)); mDrill-=cutD;
              const cutR = Math.max(0, over-cutT-cutD); mRead = Math.max(TH.readMin, mRead-cutR);
            }
            
            const tasks = [];
            const topic = pickNextTopic();

            const readingPlan = commitReadingForMinutes(topic, mRead, isFinalPhase, catalogByTopic);
            const allDoneNow = allReadingDoneSoFar();

            if (readingPlan.isExhausted || readingPlan.usedMin===0) {
              if(allDoneNow){
                tasks.push({
                    display: `Global review & error log`,
                    long: `üåÄ Review key concepts, formulas, and your error log across topics.`,
                    mins: Math.min(mRead, 25),
                    type: 'review',
                    _topic: 'Mixed Review',
                    _book: `üåÄ Review: Mixed`
                });
                mDrill += (mRead - tasks[0].mins);
              } else {
                const fill = fillReadingAcrossTopics(mRead, isFinalPhase);
                if(fill.items.length){
                  tasks.push(...fill.items);
                } else {
                  mDrill += mRead;
                }
              }
            } else {
              readingPlan.parts.forEach(p => {
                const pageStr = p.from ? (p.from === p.to ? ` (p.${p.from})` : ` (pp.${p.from}‚Äì${p.to})`) : '';
                tasks.push({
                  display: `Read: ${p.chapterTitle}${pageStr}`,
                  long: `üìò <b>${topic}</b>: ${p.bookTitle}, ${p.chapterTitle}${pageStr}`,
                  mins: p.minutes, type: 'reading', _topic: topic, _book: shortBook(p.bookTitle),
                  _section: p.sectionRef
                });
              });
            }

            // === EXERCISES MUST MATCH READING ===
            const readingTasksToday = tasks.filter(t=>t.type==='reading');
            let exSection = chooseExerciseTargetFromReadings(readingTasksToday, mDrill);
            if(!exSection && readingTasksToday.length){
              const lastTopic = readingTasksToday[readingTasksToday.length-1]._topic || topic;
              exSection = findExerciseSectionForTopic(lastTopic, mDrill);
            }
            if(!exSection){
              exSection = findExerciseSectionForTopic(topic, mDrill);
            }

            if (exSection) {
              const ex = makeExercisesFromSection(exSection, mDrill, dayIndex, totalDays, usedBookProblems);
              if(ex){ tasks.push(ex); }
              else   { tasks.push(onAIME ? buildAIMETimedSet(mDrill) : buildAMCContestTimedSet(mDrill)); }
            } else {
              tasks.push(onAIME ? buildAIMETimedSet(mDrill) : buildAMCContestTimedSet(mDrill));
            }

            // Proofs: AMC10/12 only, and only after *all reading* complete
            const allowProofNow = hasProofBooks && (onAMC10 || onAMC12) && allReadingDoneSoFar();
            if(allowProofNow){
              const proofShare = 0.16;
              const proofBudget = Math.round(minutesPerDay*proofShare);
              scheduleProof(proofBudget).forEach(t=>tasks.push(t));
            }

            // Timed set
            if(onUSAMO){
              const tag = exSection ? shortBook(exSection.bookTitle) : 'Mixed Practice';
              const chap = exSection ? shortChapter(exSection.chapterTitle) : 'Mixed';
              tasks.push({display: `Timed practice: ${chap}`, long:`‚è±Ô∏è <b>Timed set</b> ‚Äî ${tag}${exSection?`, ${exSection.chapterTitle}`:''}`, mins:mTimed, type:'timed', _book: `‚è±Ô∏è Timed ‚Äî ${tag}`});
            } else if(onAIME){
              tasks.push(buildAIMETimedSet(mTimed));
            } else if(onAMC){
              tasks.push(buildAMCContestTimedSet(mTimed));
            } else {
              const tag = exSection ? shortBook(exSection.bookTitle) : 'Mixed Practice';
              const chap = exSection ? shortChapter(exSection.chapterTitle) : 'Mixed';
              tasks.push({display: `Timed practice: ${chap}`, long:`‚è±Ô∏è <b>Timed set</b> ‚Äî ${tag}${exSection?`, ${exSection.chapterTitle}`:''}`, mins:mTimed, type:'timed', _book: `‚è±Ô∏è Timed ‚Äî ${tag}`});
            }

            tasks.push(problemOfDay());
            
            let cur = totalMin(tasks);
            if(cur < minutesPerDay - 5){
              const firstRead = tasks.find(t=>t.type==='reading');
              if(firstRead) firstRead.mins += (minutesPerDay - cur);
              else {
                const firstTimed = tasks.find(t=>t.type==='timed');
                if(firstTimed) firstTimed.mins += (minutesPerDay - cur);
              }
            }

            return tasks.filter(t => t && t.mins > 0);
          }

          /* Build all days */
          const tasksByDay = [];
          for(let d=0; d<totalDays; d++){
            const dateObj = new Date(start.getTime()+d*86400000);
            tasksByDay.push( buildDay(d, dateObj) );
          }

          const taskMap = new Map();
          for(let i=0;i<days;i++){
            const d = new Date(start.getTime()+i*86400000);
            const key = d.toISOString().slice(0,10);
            taskMap.set(key, tasksByDay[i]);
          }

          /* Render calendar */
          const months = buildMonthList(start, end);
          if(!months.length){
            console.warn('Empty month list; falling back to start month');
            months.push({year:start.getFullYear(), month:start.getMonth()});
          }
          let monthIdx = 0;
          renderOneMonth(months[monthIdx]);

          const pager1_prev = $('prevMonth'), pager1_next = $('nextMonth');
          const pager2_prev = $('prevMonth2'), pager2_next = $('nextMonth2');

          const updatePagers = () => {
            pager1_prev.disabled = pager2_prev.disabled = (monthIdx===0);
            pager1_next.disabled = pager2_next.disabled = (monthIdx===months.length-1);
          };

          const goPrev = ()=>{ if(monthIdx>0){monthIdx--;renderOneMonth(months[monthIdx]);}};
          const goNext = ()=>{ if(monthIdx<months.length-1){monthIdx++;renderOneMonth(months[monthIdx]);}};

          pager1_prev.onclick = pager2_prev.onclick = goPrev;
          pager1_next.onclick = pager2_next.onclick = goNext;


          function buildMonthList(startDate, endDate){
            const out=[]; let cur = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
            const last = new Date(endDate.getFullYear(), endDate.getMonth(), 1);
            while(cur<=last){ out.push({year:cur.getFullYear(), month:cur.getMonth()}); cur = new Date(cur.getFullYear(), cur.getMonth()+1, 1); }
            return out;
          }

          function renderOneMonth({year, month}){
            try{
              const cal = $('calendar'); cal.innerHTML='';
              const wrap=document.createElement('section'); wrap.className='month';
              const header = new Date(year, month, 1).toLocaleString(undefined,{month:'long',year:'numeric'});
              wrap.innerHTML=`<h3>${header}</h3><div class="cal"></div>`; const grid=wrap.querySelector('.cal');

              ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].forEach(d=>{
                const head=document.createElement('div'); head.className='day-header';
                head.textContent = d; grid.appendChild(head);
              });

              const firstDay=new Date(year,month,1), daysInMonth=new Date(year,month+1,0).getDate(), lead=firstDay.getDay();
              for(let i=0;i<lead;i++){ const e=document.createElement('div'); e.className='day out-of-range'; grid.appendChild(e); }

              const today = new Date(); today.setHours(0,0,0,0);
              for(let day=1; day<=daysInMonth; day++){
                const dateObj=new Date(year,month,day); dateObj.setHours(0,0,0,0);
                const key=dateObj.toISOString().slice(0,10); const tasks=taskMap.get(key)||[];
                const inRange=(dateObj>=start && dateObj<=end);
                const box=document.createElement('div'); let cls='day';
                if(!inRange) cls+=' out-of-range'; else if(dateObj<today) cls+=' past'; else if(dateObj.getTime()===today.getTime()) cls+=' today';
                box.className=cls;

                let html=`<div class="date">${day}</div>`;
                if(inRange && tasks.length > 0){
                    const grouped = tasks.reduce((acc, task) => {
                        const bookKey = task._book || 'General';
                        if (!acc[bookKey]) acc[bookKey] = [];
                        acc[bookKey].push(task);
                        return acc;
                    }, {});
                    
                    const topic = tasks.find(t=>t._topic)?.['_topic'];
                    if (topic && topic !== "Mixed Review") {
                        html += `<span class="topic-chip">${topic}</span>`;
                    }

                    const MAX_SHOWN_TASKS = 3;
                    let tasksShownCount = 0;
                    
                    for (const task of tasks) {
                        if (tasksShownCount >= MAX_SHOWN_TASKS) break;
                        const mins = (task.mins > 0) ? ` <span class="mins">(${task.mins}m)</span>` : '';
                        html += `<div class="task">${sanitizeHTML(task.display)}${mins}</div>`;
                        tasksShownCount++;
                    }

                    const remaining = tasks.length - tasksShownCount;
                    if(remaining > 0){
                      html += `<div class="more-wrap"><span class="more" data-date="${key}">+${remaining} more</span></div>`;
                    }
                }
                box.innerHTML=html;
                box.addEventListener('click',(ev)=>{
                  const moreBtn = ev.target.closest('.more');
                  if(inRange && tasks.length > 0){
                    openDayModal(key, tasks);
                  }
                  ev.preventDefault();
                  ev.stopPropagation();
                });
                grid.appendChild(box);
              }
              cal.appendChild(wrap);
              const pos = months.findIndex(m=>m.year===year&&m.month===month);
              $('monthLabel').innerText = `${header}`;
              updatePagers();
            }catch(e){
              console.error('[renderOneMonth crashed]', e);
              $('errBox').style.display='block';
              $('errBox').textContent='Calendar render error: ' + (e.message || e);
            }
          }

          /* Modal */
          const modalBackdrop = $('modalBackdrop');
          const dayTitle = $('dayTitle');
          const dayMetaGoal = $('dayMetaGoal');
          const dayContent = $('dayContent');
          $('closeModal').onclick = closeModal;
          modalBackdrop.addEventListener('click', (e)=>{ if(e.target===modalBackdrop) closeModal(); });

          function openDayModal(dateKey, tasks){
            const dt = new Date(dateKey+'T00:00:00');
            dayTitle.textContent = `${dt.toLocaleDateString(undefined,{weekday:'long', month:'long', day:'numeric'})}`;
            
            dayContent.innerHTML = tasks.map(t=>{
              const line = t.long || t.display || '';
              const mins = (t.mins>0)? `<span class="pill">${t.mins} min</span>` : '';
              return `<div class="task"><div>${sanitizeHTML(line)}</div> ${mins}</div>`;
            }).join('');
            modalBackdrop.style.display='flex';
            document.body.style.overflow='hidden';
          }
          function closeModal(){ modalBackdrop.style.display='none'; document.body.style.overflow=''; }

          /* ICS export */
          $('downloadIcs').onclick = ()=>{
            const ics = buildICS(start, days, tasksByDay, Number(input.minutesPerDay), input);
            const blob = new Blob([ics], {type:'text/calendar'});
            const url = URL.createObjectURL(blob);
            const a=document.createElement('a'); a.href=url; a.download='OlympiadPrep-StudyPlan.ics'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
          };

          function buildICS(startDate, spanDays, tasks, minutes, meta){
            function fmtUTC(x){ const y=x.getUTCFullYear(), m=String(x.getUTCMonth()+1).padStart(2,'0'), d=String(x.getUTCDate()).padStart(2,'0'), H=String(x.getUTCHours()).padStart(2,'0'), M=String(x.getUTCMinutes()).padStart(2,'0'); return `${y}${m}${d}T${H}${M}00Z`; }

            const hSel = $('studyHour')?.value || '07';
            const mSel = $('studyMin')?.value || '00';
            const ampm = $('studyAmpm')?.value || 'PM';
            const startHour12 = parseInt(hSel,10); const startMin = parseInt(mSel,10);
            let startHour = startHour12%12 + (ampm==='PM'?12:0);
            if(startHour===24) startHour = 12;
            if(startHour===12 && ampm==='AM') startHour = 0;

            const lines=['BEGIN:VCALENDAR','VERSION:2.0','PRODID:-//OlympiadPrep//StudyPlan//EN'];
            const planId = (meta.generatedAt ? hash32(meta.generatedAt) : hash32(seedStr));
            for(let i=0;i<spanDays;i++){
              const day=new Date(startDate.getTime()+i*86400000);
              const items=tasks[i]||[];
              if(!items.length || items.every(it => it.type === 'off')) continue;

              const startUTC=new Date(Date.UTC(day.getFullYear(),day.getMonth(),day.getDate(),startHour,startMin,0));
              const endUTC=new Date(startUTC.getTime()+minutes*60000);
              const desc=escapeICSText(items.map(t=>(t.long||t.display||'').replace(/<[^>]+>/g,'')).join('\n'));
              const uid = `olympiadprep-${planId}-${i}@studyplan`;
              lines.push('BEGIN:VEVENT',`UID:${uid}`, `DTSTAMP:${fmtUTC(new Date())}`, `DTSTART:${fmtUTC(startUTC)}`, `DTEND:${fmtUTC(endUTC)}`, `SUMMARY:Study ‚Ä¢ ${(meta.goal||'').toUpperCase()}`, `DESCRIPTION:${desc}`,'END:VEVENT');
            }
            lines.push('END:VCALENDAR'); return lines.join('\r\n');
          }

          /* Rebuild + Save */
          $('rebuildBtn').onclick = ()=>{
            const m = Number($('mPerDay').value||0), t = $('testDate').value;
            if(m<15 || !t){ alert('Enter minutes per day (15 or more) and a future test date.'); return; }
            const offs=[]; for(const opt of daysOffSel.options){ if(opt.selected) offs.push(Number(opt.value)); }
            input.minutesPerDay=m; input.testDate=t; input.offDays = offs;
            input.generatedAt = new Date().toISOString();
            localStorage.setItem('studyPlanInput', JSON.stringify(input));
            location.href = 'timeline.html?v=' + encodeURIComponent(input.generatedAt);
          };

          const saveBtn = $('saveCloudBtn'), saveStatus = $('saveStatus');
          function markSaved(msg){ if(saveStatus){ saveStatus.style.display='inline-flex'; saveStatus.textContent = msg||'Saved'; } }
          async function savePlanToCloud(){
            if(!window.olympAuth || !window.olympAuth.getUser || !window.olympAuth.savePlan){
              alert('Please sign in first (top-right).'); return;
            }
            const u = window.olympAuth.getUser();
            if(!u){ alert('Please sign in first.'); return; }
            try{ await window.olympAuth.savePlan(input); markSaved('Saved ‚úì'); }
            catch(e){ console.error('Cloud save failed', e); alert('Cloud save failed: ' + (e.message||e)); }
          }
          if(saveBtn){ saveBtn.onclick = savePlanToCloud; }

        }catch(e){
          console.error('[buildPlan failed]', e);
          errBox.style.display = 'block';
          errBox.textContent = 'Plan build failed: ' + (e.message || e);
        }
      })();
    })();
  </script>

  <script type="module" src="./auth.js"></script>
</body>
</html>
