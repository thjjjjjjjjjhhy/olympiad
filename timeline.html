<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Your Study Timeline - OlympiadPrep</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="styles.css">
  <style>
    :root{--fg:#111;--muted:#6b7280;--card:#fff;--accent:#0ea5e9;--grid:#e5e7eb}
    body{color:var(--fg)}
    .container{max-width:1000px;margin:0 auto;padding:0 16px}
    .card{background:var(--card);border-radius:16px;box-shadow:0 1px 4px rgba(0,0,0,.06);padding:16px}
    header .logo{font-weight:800}
    .hint{color:var(--muted);font-size:.92rem}
    .error{border-left:4px solid #ef4444;background:#fff1f2;color:#991b1b;padding:10px;border-radius:8px;margin:8px 0}
    .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{cursor:pointer;border:0;background:#0ea5e9;color:#fff;padding:10px 14px;border-radius:12px;font-weight:600}
    button.secondary{background:#e5e7eb;color:#111}
    input{border:1px solid var(--grid);border-radius:10px;padding:8px 10px}
    .cal-wrap{display:grid;gap:12px;margin-top:12px}
    .month{border:1px solid var(--grid);border-radius:14px;padding:10px}
    .month h3{margin:4px 6px 8px}
    .cal{display:grid;grid-template-columns:repeat(7,1fr);gap:6px}
    .day{border:1px solid var(--grid);border-radius:10px;padding:6px;min-height:120px;background:#fff}
    .day .date{font-weight:700;font-size:.9rem;margin-bottom:2px}
    .out-of-range{opacity:.35}
    .past{opacity:.55}
    .today{outline:2px solid var(--accent)}
    .task{font-size:.9rem;margin:4px 0;line-height:1.35}
    .task a{text-decoration:underline}
    .legend{display:flex;gap:12px;flex-wrap:wrap;margin-top:8px}
    .legend span{font-size:.86rem;background:#f8fafc;border:1px solid var(--grid);padding:4px 8px;border-radius:999px}
    .pager{display:flex;gap:10px;justify-content:center;align-items:center;margin:10px 0 0}
    .pager button:disabled{opacity:.5;cursor:not-allowed}
    @media print{
      .site-header,.toolbar,.pager{display:none!important}
      .month{break-inside:avoid}
      body{background:#fff}
      .card{box-shadow:none;border:1px solid var(--grid)}
    }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="container">
      <h1 class="logo">OlympiadPrep</h1>
      <nav class="site-nav">
        <a href="index.html">Home</a>
        <a href="planning.html">Planning</a>
        <a href="books.html">Books</a>
      </nav>
    </div>
  </header>

  <main class="container">
    <h2>üóìÔ∏è Your Study Timeline</h2>
    <div id="errBox" style="display:none" class="error"></div>
    <p class="hint" id="planSummary"></p>

    <div class="card toolbar">
      <div>
        <label><b>Minutes per day</b> <input id="mPerDay" type="number" min="15" step="5" style="width:120px"></label>
      </div>
      <div>
        <label><b>Test date</b> <input id="testDate" type="date"></label>
      </div>
      <button id="rebuildBtn" class="secondary">Rebuild plan</button>
      <button id="downloadIcs">Download calendar (.ics)</button>
      <button class="secondary" onclick="window.print()">Print</button>
    </div>

    <div class="legend">
      <span>üìò Reading (selected books)</span>
      <span>üß† Book exercises (specific numbers)</span>
      <span>üìó Proof-writing (USAMO/USAJMO)</span>
      <span>üß© Problem of the day</span>
      <span>‚è±Ô∏è Timed practice</span>
      <span>üìù Full mock</span>
    </div>

    <section id="calendar" class="cal-wrap"></section>
    <div class="pager">
      <button id="prevMonth">‚Üê Previous month</button>
      <span id="monthLabel" class="hint"></span>
      <button id="nextMonth">Next month ‚Üí</button>
    </div>
  </main>

  <footer>¬© 2025 OlympiadPrep.</footer>

<script>
(async function init(){
  const errBox = document.getElementById('errBox');
  window.addEventListener('error', (e)=>{
    errBox.style.display='block';
    errBox.textContent = 'Runtime error: ' + (e.message||'Unknown');
  });

  // ---------- Load planning payload ----------
  const input = JSON.parse(localStorage.getItem('studyPlanInput')||'null');
  const planSummary = document.getElementById('planSummary');
  if(!input){
    planSummary.innerHTML='No diagnostic found. Go back to <a href="planning.html">Planning</a>.';
    return;
  }

  // ---------- Deterministic RNG seeded by planning payload ----------
  function hashString(s){
    let h=2166136261>>>0;
    for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h = Math.imul(h,16777619); }
    return h>>>0;
  }
  const seedSource = JSON.stringify({
    goal: input.goal,
    testDate: input.testDate,
    minutesPerDay: input.minutesPerDay,
    subscores: input.subscores||{},
    selectedBooks: input.selectedBooks||[],
    generatedAt: input.generatedAt||''
  });
  let SEED = hashString(seedSource);
  function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15, t|1); t^=t+Math.imul(t^t>>>7, t|61); return ((t^t>>>14)>>>0)/4294967296; } }
  const rng = mulberry32(SEED);
  function rand(){ return rng(); }
  function randi(n){ return Math.floor(rand()*n); }

  // ---------- Dates ----------
  const today = new Date(); today.setHours(0,0,0,0);
  const todayStr = today.toISOString().slice(0,10);
  document.getElementById('testDate').min = todayStr;
  document.getElementById('mPerDay').value = input.minutesPerDay || 60;
  document.getElementById('testDate').value = input.testDate || todayStr;

  const start = new Date(today);
  const end   = new Date(document.getElementById('testDate').value); end.setHours(0,0,0,0);
  let spanDays = Math.ceil((end - start)/86400000);
  if(!(Number.isFinite(spanDays) && spanDays>0)) spanDays = 14;

  const goal = (input.goal||'amc10').toLowerCase();
  const track = (goal==='amc10'||goal==='amc12') ? 'AMC' : (goal==='aime' ? 'AIME' : (goal==='usamo' ? 'USAMO' : 'USAJMO'));
  const difficultTrack = (track==='AIME' || track==='USAMO' || track==='USAJMO');

  planSummary.innerHTML = `Start: <b>${start.toLocaleDateString()}</b> ‚Üí Test: <b>${end.toLocaleDateString()}</b> ‚Ä¢ Window: <b>${spanDays}</b> days ‚Ä¢ Goal: <b>${(input.goal||'').toUpperCase()}</b>.`;

  // ---------- Diagnostic weights (deterministic) ----------
  const subs = input.subscores || {};
  const ALL_TOPICS = ['Polynomials and Algebra','Number Theory','Geometry','Combinatorics','Probability','Sequences and Series','Functions'];
  const topics = Object.keys(subs).length ? Object.keys(subs) : ALL_TOPICS.slice();
  const weights = {};
  topics.forEach(t=>{
    const r = (subs[t]?.right||0), n = (subs[t]?.total||1);
    weights[t] = 1 - r/n + 0.05;
  });

  // Deterministic weighted pick
  const recentTopics = [];
  function pickWeightedTopic(){
    const entries = Object.entries(weights).length ? Object.entries(weights) : topics.map(t=>[t,1]);
    const sum = entries.reduce((a,[,w])=>a+w,0);
    let r = rand()*sum, choice = entries[0][0];
    for(const [k,w] of entries){ r-=w; if(r<=0){ choice=k; break; } }
    if(recentTopics.filter(x=>x===choice).length>=2){
      // pick next deterministically
      const idx = (entries.findIndex(e=>e[0]===choice)+1) % entries.length;
      choice = entries[idx][0];
    }
    recentTopics.push(choice); if(recentTopics.length>4) recentTopics.shift();
    return choice;
  }

  // ---------- Selected books (strict) ----------
  const selected = new Set(input.selectedBooks || []);

  // ---------- Banks ----------
  const V1=1, V2=2;
  function minutesPerPage(vol){ return (vol===V1)?2.0:(difficultTrack?3.0:2.6); }
  function minutesPerExercise(vol){ return (vol===V1)?6.0:(difficultTrack?9.0:8.0); }

  // Units schema:
  //  - page-based: {bookId, book, vol, topic, chapter, pStart, pEnd, ex}
  //  - section-based: {bookId, book, topic, section, ex, chunks} with chunks=how many reading splits
  const BOOK_UNITS = [
    // AoPS Volume 1 (page-based)
    {bookId:'aops-v1', book:'AoPS Volume 1', vol:V1, topic:'Number Theory', chapter:'Chapter 5.4: Modular Arithmetic', pStart:42, pEnd:45, ex:30},
    {bookId:'aops-v1', book:'AoPS Volume 1', vol:V1, topic:'Number Theory', chapter:'Chapter 5.6‚Äì5.7: Primes and Factors', pStart:47, pEnd:48, ex:18},
    {bookId:'aops-v1', book:'AoPS Volume 1', vol:V1, topic:'Combinatorics', chapter:'Chapter 25: Learning to Count', pStart:221, pEnd:229, ex:40},
    {bookId:'aops-v1', book:'AoPS Volume 1', vol:V1, topic:'Probability', chapter:'Chapter 25: Counting as a foundation for Probability', pStart:221, pEnd:229, ex:24},
    {bookId:'aops-v1', book:'AoPS Volume 1', vol:V1, topic:'Sequences and Series', chapter:'Chapter 24: Sequences and Series', pStart:211, pEnd:217, ex:28},
    {bookId:'aops-v1', book:'AoPS Volume 1', vol:V1, topic:'Functions', chapter:'Chapter 21: Functions', pStart:187, pEnd:190, ex:16},
    {bookId:'aops-v1', book:'AoPS Volume 1', vol:V1, topic:'Polynomials and Algebra', chapter:'Chapter 6: Quadratic Equations', pStart:52, pEnd:60, ex:32},
    {bookId:'aops-v1', book:'AoPS Volume 1', vol:V1, topic:'Geometry', chapter:'Chapter 11.8: Area of a Triangle', pStart:109, pEnd:109, ex:12},
    {bookId:'aops-v1', book:'AoPS Volume 1', vol:V1, topic:'Geometry', chapter:'Chapter 14‚Äì15: Angle Chasing & Area', pStart:133, pEnd:138, ex:36},
    {bookId:'aops-v1', book:'AoPS Volume 1', vol:V1, topic:'Geometry', chapter:'Chapter 18: Three-Dimensional Geometry', pStart:165, pEnd:169, ex:20},

    // AoPS Volume 2 (page-based)
    {bookId:'aops-v2', book:'AoPS Volume 2', vol:V2, topic:'Number Theory', chapter:'Chapter 23: Divisibility and Congruences', pStart:252, pEnd:262, ex:34},
    {bookId:'aops-v2', book:'AoPS Volume 2', vol:V2, topic:'Number Theory', chapter:'Chapter 24: Diophantine Equations', pStart:266, pEnd:274, ex:26},
    {bookId:'aops-v2', book:'AoPS Volume 2', vol:V2, topic:'Combinatorics', chapter:'Chapter 15: Combinatorics & Binomial', pStart:170, pEnd:176, ex:30},
    {bookId:'aops-v2', book:'AoPS Volume 2', vol:V2, topic:'Combinatorics', chapter:'Chapter 25.6: Colorings', pStart:280, pEnd:280, ex:12},
    {bookId:'aops-v2', book:'AoPS Volume 2', vol:V2, topic:'Probability', chapter:'Chapter 15.5: Distributions', pStart:175, pEnd:175, ex:10},
    {bookId:'aops-v2', book:'AoPS Volume 2', vol:V2, topic:'Sequences and Series', chapter:'Chapter 16: Sequences & Recurrences', pStart:180, pEnd:191, ex:36},
    {bookId:'aops-v2', book:'AoPS Volume 2', vol:V2, topic:'Functions', chapter:'Chapter 7: Functional Equations', pStart:69, pEnd:73, ex:18},
    {bookId:'aops-v2', book:'AoPS Volume 2', vol:V2, topic:'Polynomials and Algebra', chapter:'Chapter 6: Polynomials', pStart:52, pEnd:65, ex:34},
    {bookId:'aops-v2', book:'AoPS Volume 2', vol:V2, topic:'Geometry', chapter:'Chapter 22: Inversion & Homothety', pStart:241, pEnd:247, ex:16},

    // AoPS Intro series (section-based with deterministic chunking)
    {bookId:'prealgebra', book:'AoPS Prealgebra', topic:'Polynomials and Algebra', section:'Integers & Order of Operations', ex:30, chunks:10},
    {bookId:'intro-alg', book:'AoPS Introduction to Algebra', topic:'Polynomials and Algebra', section:'Equations & Factoring', ex:40, chunks:12},
    {bookId:'intro-alg', book:'AoPS Introduction to Algebra', topic:'Functions', section:'Functions & Graphs', ex:25, chunks:8},
    {bookId:'intro-alg', book:'AoPS Introduction to Algebra', topic:'Sequences and Series', section:'Sequences', ex:20, chunks:8},
    {bookId:'intro-cp', book:'AoPS Intro to Counting & Probability', topic:'Combinatorics', section:'Counting Strategies', ex:40, chunks:12},
    {bookId:'intro-cp', book:'AoPS Intro to Counting & Probability', topic:'Probability', section:'Basic Probability', ex:35, chunks:10},
    {bookId:'intro-geo', book:'AoPS Introduction to Geometry', topic:'Geometry', section:'Triangles & Circles', ex:50, chunks:14},
    {bookId:'intro-nt', book:'AoPS Introduction to Number Theory', topic:'Number Theory', section:'Divisibility & Primes', ex:45, chunks:12},

    // Intermediate / advanced (section-based)
    {bookId:'int-alg', book:'AoPS Intermediate Algebra', topic:'Polynomials and Algebra', section:'Polynomials & Rational Functions', ex:45, chunks:14},
    {bookId:'int-alg', book:'AoPS Intermediate Algebra', topic:'Functions', section:'Functional Equations', ex:30, chunks:10},
    {bookId:'int-alg', book:'AoPS Intermediate Algebra', topic:'Sequences and Series', section:'Recurrences', ex:30, chunks:10},
    {bookId:'int-cp',  book:'AoPS Intermediate Counting & Probability', topic:'Combinatorics', section:'Advanced Counting', ex:45, chunks:14},
    {bookId:'int-cp',  book:'AoPS Intermediate Counting & Probability', topic:'Probability', section:'Conditional & Expected Value', ex:40, chunks:12},
    {bookId:'precalc', book:'AoPS Precalculus', topic:'Functions', section:'Exponential/Log & Trig', ex:35, chunks:16},
    {bookId:'precalc', book:'AoPS Precalculus', topic:'Sequences and Series', section:'Series & Binomial', ex:30, chunks:14},
    {bookId:'precalc', book:'AoPS Precalculus', topic:'Polynomials and Algebra', section:'Complex & Roots', ex:30, chunks:14},

    // Other texts (section-based)
    {bookId:'egmo',   book:'EGMO', topic:'Geometry', section:'Power of a Point & Homothety', ex:24, chunks:12},
    {bookId:'zeitz',  book:'Zeitz ‚Äî Art & Craft', topic:'Combinatorics', section:'Pigeonhole / Extremal', ex:28, chunks:10},
    {bookId:'zeitz',  book:'Zeitz ‚Äî Art & Craft', topic:'Number Theory', section:'Modular / Diophantine', ex:24, chunks:10},
    {bookId:'engel',  book:'Engel ‚Äî Problem-Solving Strategies', topic:'Combinatorics', section:'Invariants / Extremal', ex:24, chunks:10},
    {bookId:'104nt',  book:'104 Number Theory Problems', topic:'Number Theory', section:'Problem Sets 1‚Äì4', ex:30, chunks:10},
    {bookId:'path-comb', book:'A Path to Combinatorics', topic:'Combinatorics', section:'Counting Strategies', ex:30, chunks:10},
    {bookId:'cmms',   book:'Competition Math for Middle School', topic:'Number Theory', section:'NT Core', ex:25, chunks:10},
    {bookId:'cmms',   book:'Competition Math for Middle School', topic:'Polynomials and Algebra', section:'Algebra Core', ex:25, chunks:10},
    {bookId:'cmms',   book:'Competition Math for Middle School', topic:'Probability', section:'Probability Core', ex:20, chunks:8},
    {bookId:'cmms',   book:'Competition Math for Middle School', topic:'Combinatorics', section:'Counting Core', ex:20, chunks:8},
    {bookId:'cmms',   book:'Competition Math for Middle School', topic:'Geometry', section:'Geometry Core', ex:20, chunks:8}
  ];

  // Filter to selected only
  const UNITS_BY_TOPIC = {};
  for(const u of BOOK_UNITS){
    if(!selected.has(u.bookId)) continue;
    (UNITS_BY_TOPIC[u.topic] ||= []).push(u);
  }

  // If user picked nothing (edge case), we can't schedule book work
  const hasAnyBook = Object.keys(UNITS_BY_TOPIC).length>0;

  // Per-unit progress (no repeats across days)
  const progress = new Map();
  function getProg(u){
    if(!progress.has(u)){
      const isPage = ('pStart' in u);
      progress.set(u, {
        nextPage: isPage ? u.pStart : 1,
        nextExercise: 1,
        nextChunk: 1,
        donePages: isPage ? false : false,  // section-based uses chunks instead of pages
        doneChunks: false,
        doneExercises: false
      });
    }
    return progress.get(u);
  }

  // ---------- Proof-writing (USAMO/USAJMO only, deterministic) ----------
  const PROOF_BANK = {
    velleman: [
      {id:'Vell-2', book:'Velleman ‚Äî How to Prove It', section:'Chapter 2: Sentential Logic', pStart:45, pEnd:65, ex:20},
      {id:'Vell-3', book:'Velleman ‚Äî How to Prove It', section:'Chapter 3: Quantifiers', pStart:67, pEnd:92, ex:24},
      {id:'Vell-4', book:'Velleman ‚Äî How to Prove It', section:'Chapter 4: Proofs', pStart:95, pEnd:132, ex:30}
    ],
    zeitz: [
      {id:'Zeitz-2', book:'Zeitz ‚Äî The Art and Craft of Problem Solving', section:'Chapter 2: Strategies', pStart:25, pEnd:58, ex:30},
      {id:'Zeitz-3', book:'Zeitz ‚Äî Invariants, Extremal, Pigeonhole', section:'Chapter 3 (selected)', pStart:59, pEnd:96, ex:28}
    ],
    engel: [
      {id:'Engel-1', book:'Engel ‚Äî Problem-Solving Strategies', section:'Chapter 1: Invariant Principle', pStart:1, pEnd:24, ex:20},
      {id:'Engel-2', book:'Engel ‚Äî Extremal Principle', section:'Chapter 2', pStart:25, pEnd:48, ex:20}
    ],
    egmo: [
      {id:'EGMO-5', book:'EGMO', section:'Chapter 5: Power of a Point & Homothety', pStart:97, pEnd:128, ex:24},
      {id:'EGMO-7', book:'EGMO', section:'Chapter 7: Inversion (basics)', pStart:153, pEnd:180, ex:24}
    ]
  };
  const proofSelection = ['velleman','zeitz','engel','egmo'].filter(id=>selected.has(id));
  const proofProgress = new Map();
  function getProofProg(u){
    if(!proofProgress.has(u.id)){
      proofProgress.set(u.id,{nextPage:u.pStart,nextExercise:1,donePages:false,doneExercises:false});
    }
    return proofProgress.get(u.id);
  }
  function scheduleProofBlock(minutes){
    if(!((track==='USAMO'||track==='USAJMO') && proofSelection.length && minutes>=10)) return [];
    const out=[]; let remaining=minutes;
    for(const src of proofSelection){
      const units = PROOF_BANK[src];
      for(const unit of units){
        if(remaining<10) break;
        const pp = getProofProg(unit);
        if(!pp.donePages){
          const rate=3.0, left = unit.pEnd-pp.nextPage+1;
          if(left>0){
            const pages = Math.max(2, Math.min(left, Math.floor((remaining+0.3*rate)/rate)));
            const from = pp.nextPage, to = pp.nextPage + pages - 1;
            out.push({type:'proof', mins:Math.round(pages*rate), html:`üìó <b>Proof-writing</b>: ${unit.book}, ${unit.section} (pages ${from}‚Äì${to}) ‚Äî write summaries.`});
            pp.nextPage = to + 1; if(pp.nextPage>unit.pEnd) pp.donePages=true;
            remaining -= Math.round(pages*rate);
          }
        }
        if(remaining>=10 && !pp.doneExercises){
          const per=15, left=(unit.ex||20)-(pp.nextExercise-1);
          if(left>0){
            const cnt = Math.max(1, Math.min(left, Math.floor((remaining+0.25*per)/per)));
            const s=pp.nextExercise, e=s+cnt-1;
            out.push({type:'proof', mins:Math.round(cnt*per), html:`üìó <b>Proof exercises</b>: ${unit.book}, ${unit.section}: ${s===e?`Exercise ${s}`:`Exercises ${s}‚Äì${e}`}`});
            pp.nextExercise=e+1; if(pp.nextExercise>(unit.ex||20)) pp.doneExercises=true;
            remaining -= Math.round(cnt*per);
          }
        }
      }
      if(remaining<10) break;
    }
    return out;
  }

  // ---------- Problem of the Day & Mocks (deterministic) ----------
  function amcSet(year, level, variant){ return `https://artofproblemsolving.com/wiki/index.php/${year}_AMC_${level}${variant}_Problems`; }
  function aimeSet(year, variant){ return `https://artofproblemsolving.com/wiki/index.php/${year}_AIME_${variant}_Problems`; }
  function usamoSet(year){ return `https://artofproblemsolving.com/wiki/index.php/${year}_USAMO_Problems`; }
  function usajmoSet(year){ return `https://artofproblemsolving.com/wiki/index.php/${year}_USAJMO_Problems`; }

  function allAMCProblems(level){
    const out=[], years=[...Array(25)].map((_,i)=>2001+i), variants=['A','B'];
    years.forEach(y=>variants.forEach(v=>{ for(let n=1;n<=25;n++) out.push({url: amcSet(y,level,v)+`/Problem_${n}`, label:`${y} AMC ${level}${v} Problem ${n}`}); }));
    return out;
  }
  function allAIMEProblems(){
    const out=[], years=[...Array(43)].map((_,i)=>1983+i), variants=['I','II'];
    years.forEach(y=>variants.forEach(v=>{ for(let n=1;n<=15;n++) out.push({url: aimeSet(y,v)+`/Problem_${n}`, label:`${y} AIME ${v} Problem ${n}`}); }));
    return out;
  }

  const POD_POOL = (track==='AMC') ? (goal==='amc10'? allAMCProblems(10): allAMCProblems(12))
                    : (track==='AIME' ? allAIMEProblems() : allAIMEProblems());
  const usedPOD = new Set();
  function pickPOD(){
    // deterministic walk through pool using rng
    for(let tries=0; tries<5000; tries++){
      const i = randi(POD_POOL.length);
      const k = POD_POOL[i].url;
      if(!usedPOD.has(k)){ usedPOD.add(k); return POD_POOL[i]; }
    }
    return POD_POOL[randi(POD_POOL.length)];
  }

  const usedMocks = new Set();
  function isMockDay(dateObj){
    const daysLeft = Math.ceil((end - dateObj)/86400000);
    if(daysLeft > 30 || daysLeft <= 3) return false;
    const dow = dateObj.getDay();
    if(track==='AMC'){
      if(daysLeft <= 10) return (dow===2 || dow===4 || dow===6);
      return (dow===2 || dow===6);
    }else if(track==='AIME'){
      if(daysLeft <= 10) return (dow===1 || dow===2 || dow===4 || dow===6);
      return (dow===1 || dow===4 || dow===6);
    }else{
      return (dow===2 || dow===6 || (daysLeft<=14 && dow===4));
    }
  }
  function makeMockForDate(){
    let html='';
    if(track==='AMC'){
      const lv=(goal==='amc10')?10:12;
      for(let t=0;t<2000;t++){
        const y=2006 + randi(18), v=(randi(2)===0?'A':'B');
        const url=amcSet(y,lv,v); if(!usedMocks.has(url)){ usedMocks.add(url); html=`üìù <a href="${url}" target="_blank" rel="noopener">Full mock: ${y} AMC ${lv}${v}</a>`; break; }
      }
    }else if(track==='AIME'){
      for(let t=0;t<2000;t++){
        const y=2004 + randi(21), v=(randi(2)===0?'I':'II');
        const url=aimeSet(y,v); if(!usedMocks.has(url)){ usedMocks.add(url); html=`üìù <a href="${url}" target="_blank" rel="noopener">Full mock: ${y} AIME ${v}</a>`; break; }
      }
    }else if(track==='USAMO'){
      for(let t=0;t<2000;t++){
        const y=2002 + randi(22); const url=usamoSet(y);
        if(!usedMocks.has(url)){ usedMocks.add(url); html=`üìù <a href="${url}" target="_blank" rel="noopener">Full mock: ${y} USAMO (proof)</a>`; break; }
      }
    }else{
      for(let t=0;t<2000;t++){
        const y=2010 + randi(14); const url=usajmoSet(y);
        if(!usedMocks.has(url)){ usedMocks.add(url); html=`üìù <a href="${url}" target="_blank" rel="noopener">Full mock: ${y} USAJMO (proof)</a>`; break; }
      }
    }
    return {html, type:'mock', mins:0};
  }

  // ---------- Study day builder (fills the day with BOOK work) ----------
  const THRESH = {read:10, drill:10, timed:8};
  const QUOTA_SLACK = 2;

  function unitsForTopic(topic){
    return (UNITS_BY_TOPIC[topic] || []).slice();
  }

  function totalMins(arr){ return Math.round(arr.reduce((s,t)=>s+(t.mins||0),0)); }

  function scheduleFromBooks(targetMinutes){
    // target mix: foundation of reading+exercises; small leftover can host POD/timed
    let readBudget = Math.max(8, Math.round(targetMinutes*0.58));
    let exBudget   = Math.max(6, targetMinutes - readBudget);

    const tasks=[]; const todayTopics=[];

    // Always try to place at least two blocks (topic-driven)
    for(let blocks=0; blocks<3 && (readBudget>=4 || exBudget>=6); blocks++){
      let topic = pickWeightedTopic();

      // If no units for that topic, deterministically rotate to some available topic
      let tries=0;
      while(unitsForTopic(topic).filter(u=>{
        const p=getProg(u); return !p.donePages || !p.doneExercises || !p.doneChunks;
      }).length===0 && tries<ALL_TOPICS.length){
        topic = ALL_TOPICS[(ALL_TOPICS.indexOf(topic)+1)%ALL_TOPICS.length];
        tries++;
      }
      const pool = unitsForTopic(topic).filter(u=>{
        const p=getProg(u); return !p.donePages || !p.doneExercises || !p.doneChunks;
      });
      if(!pool.length) continue;

      // Deterministic pick of unit within topic
      const idx = randi(pool.length);
      const unit = pool[idx];
      const p = getProg(unit);
      todayTopics.push(topic);

      // Reading: pages or section chunk
      if(readBudget>=4 && !p.donePages && !p.doneChunks){
        if('pStart' in unit){
          const rate = minutesPerPage(unit.vol||V1);
          const left = Math.max(0, unit.pEnd - p.nextPage + 1);
          if(left>0){
            const pages = Math.max(2, Math.min(left, Math.floor((readBudget+0.2*rate)/rate)));
            const from = p.nextPage, to = p.nextPage + pages - 1;
            tasks.push({type:'reading', mins:Math.round(pages*rate), html:`üìò <b>${topic}</b>: ${unit.book}, ${unit.chapter} (pages ${from}‚Äì${to})`});
            p.nextPage = to + 1; if(p.nextPage>unit.pEnd) p.donePages=true;
            readBudget -= Math.round(pages*rate);
          }else{
            p.donePages=true;
          }
        }else{
          // section-based: split into deterministic "chunks"
          const chunkTime = difficultTrack?16:14;
          const left = Math.max(0, (unit.chunks||10) - (p.nextChunk-1));
          if(left>0){
            const take = Math.min(left, Math.max(1, Math.floor((readBudget + 0.25*chunkTime)/chunkTime)));
            const s=p.nextChunk, e=s+take-1;
            const label = (s===e)?`Section ${s}`:`Sections ${s}‚Äì${e}`;
            tasks.push({type:'reading', mins:Math.round(take*chunkTime), html:`üìò <b>${topic}</b>: ${unit.book}, ${unit.section} ‚Äî ${label}`});
            p.nextChunk = e+1; if(p.nextChunk>(unit.chunks||10)) p.doneChunks=true;
            readBudget -= Math.round(take*chunkTime);
          }else{
            p.doneChunks=true;
          }
        }
      }

      // Exercises
      if(exBudget>=6 && !p.doneExercises){
        const per = minutesPerExercise(unit.vol||V1);
        const left = Math.max(0, (unit.ex||24) - (p.nextExercise-1));
        if(left>0){
          const cnt = Math.max(1, Math.min(left, Math.floor((exBudget+0.25*per)/per)));
          const s=p.nextExercise, e=s+cnt-1;
          const where = ('chapter' in unit) ? `${unit.book}, ${unit.chapter}` : `${unit.book}, ${unit.section}`;
          tasks.push({type:'bookex', mins:Math.round(cnt*per), html:`üß† <b>Book exercises</b> (${where}): ${s===e?`Problem ${s}`:`Problems ${s}‚Äì${e}`}`});
          p.nextExercise=e+1; if(p.nextExercise>(unit.ex||24)) p.doneExercises=true;
          exBudget -= Math.round(cnt*per);
        }else{
          p.doneExercises=true;
        }
      }
    }

    // If we still have significant leftover time, keep adding exercises from any available unit
    let leftover = readBudget + exBudget;
    if(leftover >= 6){
      // find any unit with exercises left
      outer:
      for(const T of ALL_TOPICS){
        const pool = unitsForTopic(T).filter(u=>!getProg(u).doneExercises);
        if(!pool.length) continue;
        const unit = pool[randi(pool.length)];
        const p = getProg(unit);
        const per = minutesPerExercise(unit.vol||V1);
        const cnt = Math.max(1, Math.floor((leftover+0.25*per)/per));
        const left = Math.max(0, (unit.ex||24) - (p.nextExercise-1));
        if(left>0){
          const take = Math.min(left, cnt);
          const s=p.nextExercise, e=s+take-1;
          const where = ('chapter' in unit) ? `${unit.book}, ${unit.chapter}` : `${unit.book}, ${unit.section}`;
          tasks.push({type:'bookex', mins:Math.round(take*per), html:`üß† <b>Book exercises</b> (${where}): ${s===e?`Problem ${s}`:`Problems ${s}‚Äì${e}`}`});
          p.nextExercise=e+1; if(p.nextExercise>(unit.ex||24)) p.doneExercises=true;
          leftover -= Math.round(take*per);
          if(leftover < 4) break outer;
        }
      }
    }

    // Balance to quota (¬±2 min)
    const target = targetMinutes;
    function balance(arr){
      let cur = totalMins(arr);
      if(Math.abs(cur-target) <= QUOTA_SLACK) return;
      if(cur < target){
        // add small extra exercise from last bookex/reading unit if possible
        for(let i=arr.length-1;i>=0;i--){
          const t=arr[i];
          if(t.type==='bookex'){
            t.mins += (target-cur);
            return;
          }
        }
      }else{
        // trim last practice if any, else trim last block slightly
        for(let i=arr.length-1;i>=0;i--){
          const t=arr[i];
          if(t.type==='bookex' || t.type==='reading'){
            const diff = Math.min(cur-target, Math.max(0, t.mins-4));
            t.mins -= diff; cur -= diff;
            if(Math.abs(cur-target)<=QUOTA_SLACK) return;
          }
        }
      }
    }
    balance(tasks);

    return tasks;
  }

  function addProblemOfTheDay(tasks){
    const pod = pickPOD();
    tasks.push({type:'pod', mins:0, html:`üß© <b>Problem of the day</b>: <a href="${pod.url}" target="_blank" rel="noopener">${pod.label}</a>`});
  }

  // ---------- Compose full plan (deterministic) ----------
  const minutesPerDay = Number(input.minutesPerDay||60);
  const days = spanDays;
  const tasksByDay = [];

  for(let i=0;i<days;i++){
    const dateObj = new Date(start.getTime()+i*86400000);

    // Last 3 days ‚Üí full mocks
    const daysLeftAll = Math.ceil((end - dateObj)/86400000);
    if(daysLeftAll <= 3){
      tasksByDay.push([ makeMockForDate() ]);
      continue;
    }

    // Mocks 2‚Äì4√ó/week in last 30 days (level-correct)
    if(isMockDay(dateObj)){
      tasksByDay.push([ makeMockForDate(), ...(hasAnyBook ? scheduleFromBooks(Math.max(20, Math.round(minutesPerDay*0.35))) : []) ]);
      continue;
    }

    // Regular study day (books first, always fill the day)
    let bookTasks=[];
    if(hasAnyBook){
      bookTasks = scheduleFromBooks(minutesPerDay);
    }else{
      // No books selected (edge case) ‚Üí fall back to practice links
      const p1 = pickPOD(), p2 = pickPOD();
      bookTasks = [
        {type:'timed', mins:Math.round(minutesPerDay*0.5), html:`‚è±Ô∏è Timed practice: <a href="${p1.url}" target="_blank" rel="noopener">${p1.label}</a>, <a href="${p2.url}" target="_blank" rel="noopener">${p2.label}</a>`}
      ];
    }

    // Add unique POD (link-only, no minutes, to keep calendar clean)
    addProblemOfTheDay(bookTasks);

    tasksByDay.push(bookTasks);
  }

  // ---------- Calendar rendering (month pager) ----------
  const taskMap = new Map();
  for(let i=0;i<days;i++){
    const d = new Date(start.getTime()+i*86400000);
    const key = d.toISOString().slice(0,10);
    taskMap.set(key, tasksByDay[i]);
  }

  const months = buildMonthList(start, end);
  let monthIdx=0; renderOneMonth(months[monthIdx]);
  document.getElementById('prevMonth').onclick = ()=>{ if(monthIdx>0){monthIdx--;renderOneMonth(months[monthIdx]);}};
  document.getElementById('nextMonth').onclick = ()=>{ if(monthIdx<months.length-1){monthIdx++;renderOneMonth(months[monthIdx]);}};

  document.getElementById('downloadIcs').onclick = ()=>{
    const ics = buildICS(start, days, tasksByDay, minutesPerDay, track);
    const blob = new Blob([ics], {type:'text/calendar'}); const url = URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='OlympiadPrep-StudyPlan.ics'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  };
  document.getElementById('rebuildBtn').onclick = ()=>{
    const m = Number(document.getElementById('mPerDay').value||0), t = document.getElementById('testDate').value;
    if(m<15 || !t){ alert('Enter minutes per day (15 or more) and a future test date.'); return; }
    input.minutesPerDay=m; input.testDate=t; localStorage.setItem('studyPlanInput', JSON.stringify(input)); location.href = 'timeline.html?v=rebuild';
  };

  function buildMonthList(startDate, endDate){
    const out=[]; let cur = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
    const last = new Date(endDate.getFullYear(), endDate.getMonth(), 1);
    while(cur<=last){ out.push({year:cur.getFullYear(), month:cur.getMonth()}); cur = new Date(cur.getFullYear(), cur.getMonth()+1, 1); }
    return out;
  }
  function renderOneMonth({year, month}){
    const cal = document.getElementById('calendar'); cal.innerHTML='';
    const wrap=document.createElement('section'); wrap.className='month';
    const header = new Date(year, month, 1).toLocaleString(undefined,{month:'long',year:'numeric'});
    wrap.innerHTML=`<h3>${header}</h3><div class="cal"></div>`; const grid=wrap.querySelector('.cal');

    ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'].forEach(d=>{
      const head=document.createElement('div'); head.className='day'; head.style.background='#f8fafc';
      head.innerHTML=`<div class="date" style="opacity:.7">${d}</div>`; grid.appendChild(head);
    });

    const firstDay=new Date(year,month,1), daysInMonth=new Date(year,month+1,0).getDate(), lead=firstDay.getDay();
    for(let i=0;i<lead;i++){ const e=document.createElement('div'); e.className='day out-of-range'; grid.appendChild(e); }

    const t0 = new Date(); t0.setHours(0,0,0,0);
    for(let day=1; day<=daysInMonth; day++){
      const dateObj=new Date(year,month,day); dateObj.setHours(0,0,0,0);
      const key=dateObj.toISOString().slice(0,10); const tasks=taskMap.get(key)||[];
      const inRange=(dateObj>=start && dateObj<=end);
      const box=document.createElement('div'); let cls='day';
      if(!inRange) cls+=' out-of-range'; else if(dateObj<t0) cls+=' past'; else if(dateObj.getTime()===t0.getTime()) cls+=' today';
      box.className=cls;

      let html=`<div class="date">${day}</div>`;
      if(inRange){ tasks.forEach(t=>{ html += `<div class="task">${t.html}</div>`; }); }
      box.innerHTML=html; grid.appendChild(box);
    }
    cal.appendChild(wrap);
    document.getElementById('monthLabel').innerText = `Month ${months.indexOf(months.find(m=>m.year===year&&m.month===month))+1} of ${months.length} ‚Ä¢ ${header}`;
    document.getElementById('prevMonth').disabled=(monthIdx===0);
    document.getElementById('nextMonth').disabled=(monthIdx===months.length-1);
  }

  // ---------- ICS ----------
  function buildICS(startDate, spanDays, tasks, minutes, trackLabel){
    function fmtUTC(x){ const y=x.getUTCFullYear(), m=String(x.getUTCMonth()+1).padStart(2,'0'), d=String(x.getUTCDate()).padStart(2,'0'), H=String(x.getUTCHours()+0).padStart(2,'0'), M=String(x.getUTCMinutes()+0).padStart(2,'0'); return `${y}${m}${d}T${H}${M}00Z`; }
    const lines=['BEGIN:VCALENDAR','VERSION:2.0','PRODID:-//OlympiadPrep//StudyPlan//EN'];
    for(let i=0;i<spanDays;i++){
      const day=new Date(startDate.getTime()+i*86400000); const items=tasks[i]||[]; if(!items.length) continue;
      const startUTC=new Date(Date.UTC(day.getFullYear(),day.getMonth(),day.getDate(),21,0,0)); const endUTC=new Date(startUTC.getTime()+minutes*60000);
      const desc=items.map(t=>t.html.replace(/<[^>]+>/g,'')).join('\\n');
      lines.push('BEGIN:VEVENT',`UID:olympiadprep-${i}@studyplan`, `DTSTAMP:${fmtUTC(new Date())}`, `DTSTART:${fmtUTC(startUTC)}`, `DTEND:${fmtUTC(endUTC)}`, `SUMMARY:Study ‚Ä¢ ${trackLabel}`, `DESCRIPTION:${desc}`,'END:VEVENT');
    }
    lines.push('END:VCALENDAR'); return lines.join('\r\n');
  }
})();
</script>
</body>
</html>
